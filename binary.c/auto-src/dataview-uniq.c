/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"


const asn1SccT_UInt32 numBase_JointTrajectory = 200;
const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform = 200;
const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint = 200;
const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench = 200;
const asn1SccT_UInt32 numStd_vector_Wrappers_Vector4d = 200;
const asn1SccT_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory = 200;
const asn1SccT_UInt32 numBase_JointLimits_names = 200;
const asn1SccT_UInt32 numBase_JointLimits_elements = 200;
const asn1SccT_UInt32 numBase_JointsTrajectory_names = 200;
const asn1SccT_UInt32 numBase_JointsTrajectory_elements = 200;
const asn1SccT_UInt32 numBase_JointsTrajectory_times_val = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointLimitRange_elements = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointState_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_Wrench_elements = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointTrajectory_elements = 200;
const asn1SccT_UInt32 numBase_samples_DepthMap_timestamps = 200;
const asn1SccT_UInt32 numBase_samples_DepthMap_vertical_interval = 200;
const asn1SccT_UInt32 numBase_samples_DepthMap_horizontal_interval = 200;
const asn1SccT_UInt32 numBase_samples_DepthMap_distances = 200;
const asn1SccT_UInt32 numBase_samples_DepthMap_remissions = 200;
const asn1SccT_UInt32 numBase_samples_DistanceImage_data = 200;
const asn1SccT_UInt32 numBase_commands_Joints_names = 200;
const asn1SccT_UInt32 numBase_samples_LaserScan_ranges = 200;
const asn1SccT_UInt32 numBase_samples_LaserScan_remission = 200;
const asn1SccT_UInt32 numBase_samples_Pointcloud_points = 200;
const asn1SccT_UInt32 numBase_samples_Pointcloud_colors = 200;
const asn1SccT_UInt32 numBase_samples_Sonar_timestamps = 200;
const asn1SccT_UInt32 numBase_samples_Sonar_bearings = 200;
const asn1SccT_UInt32 numBase_samples_Sonar_bins = 200;
const asn1SccT_UInt32 numBase_samples_SonarBeam_beam = 200;
const asn1SccT_UInt32 numBase_samples_SonarScan_data = 200;
const asn1SccT_UInt32 numBase_samples_SonarScan_time_beams = 200;
const asn1SccT_UInt32 numBase_samples_Wrenches_names = 200;
const asn1SccT_UInt32 numBase_samples_Wrenches_elements = 200;
const asn1SccT_UInt32 numBase_JointTransformVector_names = 200;
const asn1SccT_UInt32 numBase_JointTransformVector_elements = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_Base_JointTransform_elements = 200;
const asn1SccT_UInt32 numBase_samples_frame_Frame_image = 200;
const asn1SccT_UInt32 numBase_samples_frame_Frame_attributes = 200;
const asn1SccT_UInt32 numWrappers_MatrixXd_data = 200;
const asn1SccT_UInt32 numWrappers_VectorXd_data = 200;
const asn1SccT_UInt32 numBase_JointTransformVector_m_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_base_JointTransform_m_names = 200;
const asn1SccT_UInt32 numBase_NamedVector_base_Wrench_m_names = 200;
const asn1SccT_UInt32 numBase_samples_Pointcloud_m_points = 200;
const asn1SccT_UInt32 numBase_samples_Pointcloud_m_colors = 200;
const asn1SccT_UInt32 numBase_samples_Wrenches_m_names = 200;
const asn1SccT_UInt32 numWrappers_geometry_Spline_knots = 200;
const asn1SccT_UInt32 numWrappers_geometry_Spline_vertices = 200;
const asn1SccT_UInt32 numT_String = 40;


void asn1SccBase_JointState_MODE_Initialize(asn1SccBase_JointState_MODE* pVal)
{

	(*(pVal)) = asn1Sccbase_jointstate_mode_acceleration;
}

flag asn1SccBase_JointState_MODE_IsConstraintValid(const asn1SccBase_JointState_MODE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((*(pVal)) == asn1Sccbase_jointstate_mode_acceleration)) || (((*(pVal)) == asn1Sccbase_jointstate_mode_effort)))) || (((*(pVal)) == asn1Sccbase_jointstate_mode_position)))) || (((*(pVal)) == asn1Sccbase_jointstate_mode_raw)))) || (((*(pVal)) == asn1Sccbase_jointstate_mode_speed)))) || (((*(pVal)) == asn1Sccbase_jointstate_mode_unset)));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_MODE;

	return ret;
}

flag asn1SccBase_JointState_MODE_Encode(const asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_jointstate_mode_acceleration:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_effort:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_position:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_raw:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_speed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_unset:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointState_MODE_Decode(asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_acceleration;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_effort;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_position;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_raw;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_speed;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccbase_jointstate_mode_unset;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_jointstate_mode_acceleration;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_JointState_MODE_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointState_MODE_ACN_Encode(const asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_jointstate_mode_acceleration:
	            intVal = 0;
	            break;
	        case asn1Sccbase_jointstate_mode_effort:
	            intVal = 1;
	            break;
	        case asn1Sccbase_jointstate_mode_position:
	            intVal = 2;
	            break;
	        case asn1Sccbase_jointstate_mode_raw:
	            intVal = 3;
	            break;
	        case asn1Sccbase_jointstate_mode_speed:
	            intVal = 4;
	            break;
	        case asn1Sccbase_jointstate_mode_unset:
	            intVal = 5;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_JOINTSTATE_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 5);
    }

	
    return ret;
}

flag asn1SccBase_JointState_MODE_ACN_Decode(asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 5);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_MODE;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_acceleration;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_effort;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_position;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_raw;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_speed;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccbase_jointstate_mode_unset;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_JOINTSTATE_MODE;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_JointState_MODE_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Time_Resolution_Initialize(asn1SccBase_Time_Resolution* pVal)
{

	(*(pVal)) = asn1Sccbase_time_resolution_microseconds;
}

flag asn1SccBase_Time_Resolution_IsConstraintValid(const asn1SccBase_Time_Resolution* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == asn1Sccbase_time_resolution_microseconds)) || (((*(pVal)) == asn1Sccbase_time_resolution_milliseconds)))) || (((*(pVal)) == asn1Sccbase_time_resolution_seconds)));
    *pErrCode = ret ? 0 :  ERR_BASE_TIME_RESOLUTION;

	return ret;
}

flag asn1SccBase_Time_Resolution_Encode(const asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_time_resolution_microseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_time_resolution_milliseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_time_resolution_seconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_TIME_RESOLUTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_Time_Resolution_Decode(asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_TIME_RESOLUTION;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_time_resolution_microseconds;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_time_resolution_milliseconds;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_time_resolution_seconds;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_TIME_RESOLUTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_time_resolution_microseconds;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_Time_Resolution_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Time_Resolution_ACN_Encode(const asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_time_resolution_microseconds:
	            intVal = 0;
	            break;
	        case asn1Sccbase_time_resolution_milliseconds:
	            intVal = 1;
	            break;
	        case asn1Sccbase_time_resolution_seconds:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_TIME_RESOLUTION;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	
    return ret;
}

flag asn1SccBase_Time_Resolution_ACN_Decode(asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIME_RESOLUTION;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_time_resolution_microseconds;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_time_resolution_milliseconds;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_time_resolution_seconds;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_TIME_RESOLUTION;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_Time_Resolution_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_geometry_SplineBase_CoordinateType_Initialize(asn1SccBase_geometry_SplineBase_CoordinateType* pVal)
{

	(*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((((((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next)) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next)))) || (((*(pVal)) == asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior)));
    *pErrCode = ret ? 0 :  ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;

	return ret;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_Encode(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_Decode(asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior;
	                break;
	            case 6: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next;
	                break;
	            case 7: 
	                (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_ACN_Encode(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next:
	            intVal = 0;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior:
	            intVal = 1;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point:
	            intVal = 2;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point:
	            intVal = 3;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next:
	            intVal = 4;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior:
	            intVal = 5;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next:
	            intVal = 6;
	            break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior:
	            intVal = 7;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 7);
    }

	
    return ret;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_ACN_Decode(asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 7);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior;
	            break;
	        case 6:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next;
	            break;
	        case 7:
	            (*(pVal)) = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((*(pVal)) == asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error)) || (((*(pVal)) == asn1Sccbase_samples_depthmap_depth_measurement_state_too_far)))) || (((*(pVal)) == asn1Sccbase_samples_depthmap_depth_measurement_state_too_near)))) || (((*(pVal)) == asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;

	return ret;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_too_far;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_too_near;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_ACN_Encode(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_far:
	            intVal = 1;
	            break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_near:
	            intVal = 2;
	            break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement:
	            intVal = 3;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 3);
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_ACN_Decode(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_too_far;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_too_near;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_planar;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((*(pVal)) == asn1Sccbase_samples_depthmap_projection_type_planar)) || (((*(pVal)) == asn1Sccbase_samples_depthmap_projection_type_polar)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;

	return ret;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_depthmap_projection_type_planar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccbase_samples_depthmap_projection_type_polar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_planar;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_polar;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_planar;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_ACN_Encode(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_depthmap_projection_type_planar:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_depthmap_projection_type_polar:
	            intVal = 1;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_ACN_Decode(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_planar;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_projection_type_polar;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_DepthMap_UNIT_AXIS_Initialize(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_x;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == asn1Sccbase_samples_depthmap_unit_axis_unit_x)) || (((*(pVal)) == asn1Sccbase_samples_depthmap_unit_axis_unit_y)))) || (((*(pVal)) == asn1Sccbase_samples_depthmap_unit_axis_unit_z)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;

	return ret;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_Encode(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_x:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_y:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_z:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_Decode(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_x;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_y;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_z;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_x;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_ACN_Encode(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_x:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_y:
	            intVal = 1;
	            break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_z:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_ACN_Decode(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_x;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_y;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_samples_depthmap_unit_axis_unit_z;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_LASER_RANGE_ERRORS_Initialize(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((*(pVal)) == asn1Sccbase_samples_laser_range_errors_end_laser_range_errors)) || (((*(pVal)) == asn1Sccbase_samples_laser_range_errors_max_range_error)))) || (((*(pVal)) == asn1Sccbase_samples_laser_range_errors_measurement_error)))) || (((*(pVal)) == asn1Sccbase_samples_laser_range_errors_other_range_errors)))) || (((*(pVal)) == asn1Sccbase_samples_laser_range_errors_too_far)))) || (((*(pVal)) == asn1Sccbase_samples_laser_range_errors_too_near)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASER_RANGE_ERRORS;

	return ret;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_Encode(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_laser_range_errors_end_laser_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_max_range_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_other_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_Decode(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_max_range_error;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_measurement_error;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_other_range_errors;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_too_far;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccbase_samples_laser_range_errors_too_near;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_ACN_Encode(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_laser_range_errors_end_laser_range_errors:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_laser_range_errors_max_range_error:
	            intVal = 1;
	            break;
	        case asn1Sccbase_samples_laser_range_errors_measurement_error:
	            intVal = 2;
	            break;
	        case asn1Sccbase_samples_laser_range_errors_other_range_errors:
	            intVal = 3;
	            break;
	        case asn1Sccbase_samples_laser_range_errors_too_far:
	            intVal = 4;
	            break;
	        case asn1Sccbase_samples_laser_range_errors_too_near:
	            intVal = 5;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 5);
    }

	
    return ret;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_ACN_Decode(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 5);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_max_range_error;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_measurement_error;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_other_range_errors;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_too_far;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccbase_samples_laser_range_errors_too_near;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_frame_mode_t_Initialize(asn1SccBase_samples_frame_frame_mode_t* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
}

flag asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_mode_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((((((((((((((((((((((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_compressed_modes)) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_bgr)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_png)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_undefined)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_mode_t_raw_modes)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T;

	return ret;
}

flag asn1SccBase_samples_frame_frame_mode_t_Encode(const asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_png:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_mode_t_Decode(asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	                break;
	            case 6: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	                break;
	            case 7: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	                break;
	            case 8: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	                break;
	            case 9: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	                break;
	            case 10: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	                break;
	            case 11: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	                break;
	            case 12: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	                break;
	            case 13: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	                break;
	            case 14: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	                break;
	            case 15: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_frame_mode_t_ACN_Encode(const asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:
	            intVal = 1;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:
	            intVal = 2;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:
	            intVal = 3;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:
	            intVal = 4;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:
	            intVal = 5;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:
	            intVal = 6;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:
	            intVal = 7;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:
	            intVal = 8;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:
	            intVal = 9;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_png:
	            intVal = 10;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:
	            intVal = 11;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:
	            intVal = 12;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:
	            intVal = 13;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:
	            intVal = 14;
	            break;
	        case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:
	            intVal = 15;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 15);
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_mode_t_ACN_Decode(asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 15);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	            break;
	        case 6:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	            break;
	        case 7:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	            break;
	        case 8:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	            break;
	        case 9:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	            break;
	        case 10:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	            break;
	        case 11:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	            break;
	        case 12:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	            break;
	        case 13:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	            break;
	        case 14:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	            break;
	        case 15:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_frame_status_t_Initialize(asn1SccBase_samples_frame_frame_status_t* pVal)
{

	(*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_empty;
}

flag asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_status_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == asn1Sccbase_samples_frame_frame_status_t_status_empty)) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_status_t_status_invalid)))) || (((*(pVal)) == asn1Sccbase_samples_frame_frame_status_t_status_valid)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T;

	return ret;
}

flag asn1SccBase_samples_frame_frame_status_t_Encode(const asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccbase_samples_frame_frame_status_t_status_empty:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_status_t_Decode(asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_empty;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_frame_status_t_ACN_Encode(const asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccbase_samples_frame_frame_status_t_status_empty:
	            intVal = 0;
	            break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_invalid:
	            intVal = 1;
	            break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_valid:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_status_t_ACN_Decode(asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_geometry_SplineType_Initialize(asn1SccWrappers_geometry_SplineType* pVal)
{

	(*(pVal)) = asn1Sccwrappers_geometry_splinetype_degenerate;
}

flag asn1SccWrappers_geometry_SplineType_IsConstraintValid(const asn1SccWrappers_geometry_SplineType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((*(pVal)) == asn1Sccwrappers_geometry_splinetype_degenerate)) || (((*(pVal)) == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)))) || (((*(pVal)) == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)))) || (((*(pVal)) == asn1Sccwrappers_geometry_splinetype_rational_bezier)))) || (((*(pVal)) == asn1Sccwrappers_geometry_splinetype_rational_bspline)));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINETYPE;

	return ret;
}

flag asn1SccWrappers_geometry_SplineType_Encode(const asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccWrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccwrappers_geometry_splinetype_degenerate:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:
	    	    *pErrCode = ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_geometry_SplineType_Decode(asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccwrappers_geometry_splinetype_degenerate;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	                break;
	            default:
		            *pErrCode = ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccwrappers_geometry_splinetype_degenerate;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccWrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_geometry_SplineType_ACN_Encode(const asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccWrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccwrappers_geometry_splinetype_degenerate:
	            intVal = 0;
	            break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:
	            intVal = 1;
	            break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:
	            intVal = 2;
	            break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bezier:
	            intVal = 3;
	            break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bspline:
	            intVal = 4;
	            break;
	        default:
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE;                 /*COVERAGE_IGNORE*/
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
    }

	
    return ret;
}

flag asn1SccWrappers_geometry_SplineType_ACN_Decode(asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;
	if (ret) {
	    switch (intVal) {
	        case 0:
	            (*(pVal)) = asn1Sccwrappers_geometry_splinetype_degenerate;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	            break;
	    default:
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;                 /*COVERAGE_IGNORE*/
	    }
	}

    return ret && asn1SccWrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32;

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    }

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    }

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32;

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    }

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    }

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccDummyBase_T_Initialize(asn1SccDummyBase_T* pVal)
{

	asn1SccT_UInt32_Initialize(pVal);
}

flag asn1SccDummyBase_T_IsConstraintValid(const asn1SccDummyBase_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_DUMMYBASE_T;

	return ret;
}

flag asn1SccDummyBase_T_Encode(const asn1SccDummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccDummyBase_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccT_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccDummyBase_T_Decode(asn1SccDummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccT_UInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccDummyBase_T_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDummyBase_T_ACN_Encode(const asn1SccDummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccDummyBase_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    }

	
    return ret;
}

flag asn1SccDummyBase_T_ACN_Decode(asn1SccDummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DUMMYBASE_T;

    return ret && asn1SccDummyBase_T_IsConstraintValid(pVal, pErrCode);
}



void asn1SccDummy2Base_T_Initialize(asn1SccDummy2Base_T* pVal)
{

	asn1SccDummyBase_T_Initialize(pVal);
}

flag asn1SccDummy2Base_T_IsConstraintValid(const asn1SccDummy2Base_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_DUMMY2BASE_T;

	return ret;
}

flag asn1SccDummy2Base_T_Encode(const asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccDummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccDummyBase_T_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccDummy2Base_T_Decode(asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccDummyBase_T_Decode(pVal, pBitStrm, pErrCode);

	return ret  && asn1SccDummy2Base_T_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDummy2Base_T_ACN_Encode(const asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccDummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    }

	
    return ret;
}

flag asn1SccDummy2Base_T_ACN_Decode(asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DUMMY2BASE_T;

    return ret && asn1SccDummy2Base_T_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Time_Initialize(asn1SccT_Time* pVal)
{


	/*set secs */
	asn1SccT_UInt32_Initialize((&(pVal->secs)));
	/*set nsecs */
	asn1SccT_UInt32_Initialize((&(pVal->nsecs)));
}

flag asn1SccT_Time_IsConstraintValid(const asn1SccT_Time *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->secs <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_TIME_SECS;
    if (ret) {
        ret = (pVal->nsecs <= 4294967295UL);
        *pErrCode = ret ? 0 :  ERR_T_TIME_NSECS;
    }

	return ret;
}

flag asn1SccT_Time_Encode(const asn1SccT_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode secs */
	    ret = asn1SccT_UInt32_Encode((&(pVal->secs)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode nsecs */
	        ret = asn1SccT_UInt32_Encode((&(pVal->nsecs)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccT_Time_Decode(asn1SccT_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode secs */
	ret = asn1SccT_UInt32_Decode((&(pVal->secs)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode nsecs */
	    ret = asn1SccT_UInt32_Decode((&(pVal->nsecs)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_Time_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Time_ACN_Encode(const asn1SccT_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode secs */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->secs, 0, 4294967295LL);
	    if (ret) {
	        /*Encode nsecs */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->nsecs, 0, 4294967295LL);
	    }
    }

	
    return ret;
}

flag asn1SccT_Time_ACN_Decode(asn1SccT_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode secs */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->secs)), 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_TIME_SECS;
	if (ret) {
	    /*Decode nsecs */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->nsecs)), 0, 4294967295LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_T_TIME_NSECS;
	}

    return ret && asn1SccT_Time_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8;

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    }

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    }

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8;

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    }

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    }

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{

	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_T_BOOLEAN;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Double_Initialize(asn1SccT_Double* pVal)
{

	(*(pVal)) = 0.00000000000000000000E+000;
}

flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_T_DOUBLE;

	return ret;
}

flag asn1SccT_Double_Encode(const asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Double_Decode(asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;

	return ret  && asn1SccT_Double_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Double_ACN_Encode(const asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Double_ACN_Decode(asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_DOUBLE;

    return ret && asn1SccT_Double_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Angle_Initialize(asn1SccBase_Angle* pVal)
{


	/*set rad */
	asn1SccT_Double_Initialize((&(pVal->rad)));
}

flag asn1SccBase_Angle_IsConstraintValid(const asn1SccBase_Angle *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->rad) && (pVal->rad <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_ANGLE_RAD;

	return ret;
}

flag asn1SccBase_Angle_Encode(const asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rad */
	    ret = asn1SccT_Double_Encode((&(pVal->rad)), pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccBase_Angle_Decode(asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rad */
	ret = asn1SccT_Double_Decode((&(pVal->rad)), pBitStrm, pErrCode);

	return ret  && asn1SccBase_Angle_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Angle_ACN_Encode(const asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rad */
	    BitStream_EncodeReal(pBitStrm, pVal->rad);
    }

	
    return ret;
}

flag asn1SccBase_Angle_ACN_Decode(asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rad */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rad)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_ANGLE_RAD;

    return ret && asn1SccBase_Angle_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_commands_Motion2D_Initialize(asn1SccBase_commands_Motion2D* pVal)
{


	/*set translation */
	asn1SccT_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	asn1SccT_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	asn1SccBase_Angle_Initialize((&(pVal->heading)));
}

flag asn1SccBase_commands_Motion2D_IsConstraintValid(const asn1SccBase_commands_Motion2D *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_TRANSLATION;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_ROTATION;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD;
        }
    }

	return ret;
}

flag asn1SccBase_commands_Motion2D_Encode(const asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Motion2D_Decode(asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_commands_Motion2D_ACN_Encode(const asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    BitStream_EncodeReal(pBitStrm, pVal->translation);
	    if (ret) {
	        /*Encode rotation */
	        BitStream_EncodeReal(pBitStrm, pVal->rotation);
	        if (ret) {
	            /*Encode heading */
	            /*Encode rad */
	            BitStream_EncodeReal(pBitStrm, pVal->heading.rad);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Motion2D_ACN_Decode(asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->translation)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_MOTION2D_TRANSLATION;
	if (ret) {
	    /*Decode rotation */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rotation)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_MOTION2D_ROTATION;
	    if (ret) {
	        /*Decode heading */
	        /*Decode rad */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heading.rad)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_MOTION2D_HEADING_RAD;
	    }
	}

    return ret && asn1SccBase_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_PoseUpdateThreshold_Initialize(asn1SccBase_PoseUpdateThreshold* pVal)
{


	/*set distance */
	asn1SccT_Double_Initialize((&(pVal->distance)));
	/*set angle */
	asn1SccT_Double_Initialize((&(pVal->angle)));
}

flag asn1SccBase_PoseUpdateThreshold_IsConstraintValid(const asn1SccBase_PoseUpdateThreshold *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->distance) && (pVal->distance <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_ANGLE;
    }

	return ret;
}

flag asn1SccBase_PoseUpdateThreshold_Encode(const asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode distance */
	    ret = asn1SccT_Double_Encode((&(pVal->distance)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode angle */
	        ret = asn1SccT_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_PoseUpdateThreshold_Decode(asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode distance */
	ret = asn1SccT_Double_Decode((&(pVal->distance)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode angle */
	    ret = asn1SccT_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_PoseUpdateThreshold_ACN_Encode(const asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode distance */
	    BitStream_EncodeReal(pBitStrm, pVal->distance);
	    if (ret) {
	        /*Encode angle */
	        BitStream_EncodeReal(pBitStrm, pVal->angle);
	    }
    }

	
    return ret;
}

flag asn1SccBase_PoseUpdateThreshold_ACN_Decode(asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode distance */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->distance)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSEUPDATETHRESHOLD_DISTANCE;
	if (ret) {
	    /*Decode angle */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angle)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSEUPDATETHRESHOLD_ANGLE;
	}

    return ret && asn1SccBase_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Temperature_Initialize(asn1SccBase_Temperature* pVal)
{


	/*set kelvin */
	asn1SccT_Double_Initialize((&(pVal->kelvin)));
}

flag asn1SccBase_Temperature_IsConstraintValid(const asn1SccBase_Temperature *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->kelvin) && (pVal->kelvin <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TEMPERATURE_KELVIN;

	return ret;
}

flag asn1SccBase_Temperature_Encode(const asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode kelvin */
	    ret = asn1SccT_Double_Encode((&(pVal->kelvin)), pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccBase_Temperature_Decode(asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode kelvin */
	ret = asn1SccT_Double_Decode((&(pVal->kelvin)), pBitStrm, pErrCode);

	return ret  && asn1SccBase_Temperature_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Temperature_ACN_Encode(const asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode kelvin */
	    BitStream_EncodeReal(pBitStrm, pVal->kelvin);
    }

	
    return ret;
}

flag asn1SccBase_Temperature_ACN_Decode(asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode kelvin */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->kelvin)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TEMPERATURE_KELVIN;

    return ret && asn1SccBase_Temperature_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_commands_Speed6D_Initialize(asn1SccBase_commands_Speed6D* pVal)
{


	/*set surge */
	asn1SccT_Double_Initialize((&(pVal->surge)));
	/*set sway */
	asn1SccT_Double_Initialize((&(pVal->sway)));
	/*set heave */
	asn1SccT_Double_Initialize((&(pVal->heave)));
	/*set roll */
	asn1SccT_Double_Initialize((&(pVal->roll)));
	/*set pitch */
	asn1SccT_Double_Initialize((&(pVal->pitch)));
	/*set yaw */
	asn1SccT_Double_Initialize((&(pVal->yaw)));
}

flag asn1SccBase_commands_Speed6D_IsConstraintValid(const asn1SccBase_commands_Speed6D *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->surge) && (pVal->surge <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SURGE;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->sway) && (pVal->sway <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SWAY;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heave) && (pVal->heave <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_HEAVE;
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->roll) && (pVal->roll <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_ROLL;
                if (ret) {
                    ret = ((-1.79769313486231570000E+308 <= pVal->pitch) && (pVal->pitch <= 1.79769313486231570000E+308));
                    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_PITCH;
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->yaw) && (pVal->yaw <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_YAW;
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_commands_Speed6D_Encode(const asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode surge */
	    ret = asn1SccT_Double_Encode((&(pVal->surge)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sway */
	        ret = asn1SccT_Double_Encode((&(pVal->sway)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heave */
	            ret = asn1SccT_Double_Encode((&(pVal->heave)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode roll */
	                ret = asn1SccT_Double_Encode((&(pVal->roll)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode pitch */
	                    ret = asn1SccT_Double_Encode((&(pVal->pitch)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode yaw */
	                        ret = asn1SccT_Double_Encode((&(pVal->yaw)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Speed6D_Decode(asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode surge */
	ret = asn1SccT_Double_Decode((&(pVal->surge)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sway */
	    ret = asn1SccT_Double_Decode((&(pVal->sway)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heave */
	        ret = asn1SccT_Double_Decode((&(pVal->heave)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode roll */
	            ret = asn1SccT_Double_Decode((&(pVal->roll)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode pitch */
	                ret = asn1SccT_Double_Decode((&(pVal->pitch)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode yaw */
	                    ret = asn1SccT_Double_Decode((&(pVal->yaw)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_commands_Speed6D_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_commands_Speed6D_ACN_Encode(const asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode surge */
	    BitStream_EncodeReal(pBitStrm, pVal->surge);
	    if (ret) {
	        /*Encode sway */
	        BitStream_EncodeReal(pBitStrm, pVal->sway);
	        if (ret) {
	            /*Encode heave */
	            BitStream_EncodeReal(pBitStrm, pVal->heave);
	            if (ret) {
	                /*Encode roll */
	                BitStream_EncodeReal(pBitStrm, pVal->roll);
	                if (ret) {
	                    /*Encode pitch */
	                    BitStream_EncodeReal(pBitStrm, pVal->pitch);
	                    if (ret) {
	                        /*Encode yaw */
	                        BitStream_EncodeReal(pBitStrm, pVal->yaw);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Speed6D_ACN_Decode(asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode surge */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->surge)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_SURGE;
	if (ret) {
	    /*Decode sway */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->sway)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_SWAY;
	    if (ret) {
	        /*Decode heave */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heave)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_HEAVE;
	        if (ret) {
	            /*Decode roll */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->roll)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_ROLL;
	            if (ret) {
	                /*Decode pitch */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pitch)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_PITCH;
	                if (ret) {
	                    /*Decode yaw */
	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->yaw)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_SPEED6D_YAW;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_commands_Speed6D_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_AngleAxisd_axis_Initialize(asn1SccWrappers_AngleAxisd_axis* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_AngleAxisd_Initialize(asn1SccWrappers_AngleAxisd* pVal)
{


	/*set angle */
	asn1SccT_Double_Initialize((&(pVal->angle)));
	/*set axis */
	asn1SccWrappers_AngleAxisd_axis_Initialize((&(pVal->axis)));
}

flag asn1SccWrappers_AngleAxisd_IsConstraintValid(const asn1SccWrappers_AngleAxisd *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_ANGLE;
    if (ret) {
        ret = ((1 <= pVal->axis.nCount) && (pVal->axis.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS;
        for(i1 = 0; ret && i1 < pVal->axis.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->axis.arr[i1]) && (pVal->axis.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM;
        }

    }

	return ret;
}

flag asn1SccWrappers_AngleAxisd_Encode(const asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode angle */
	    ret = asn1SccT_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode axis */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->axis.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccT_Double_Encode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_AngleAxisd_Decode(asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode angle */
	ret = asn1SccT_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode axis */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS;
	    pVal->axis.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Decode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccWrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_AngleAxisd_ACN_Encode(const asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode angle */
	    BitStream_EncodeReal(pBitStrm, pVal->angle);
	    if (ret) {
	        /*Encode axis */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->axis.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->axis.arr[i1]);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_AngleAxisd_ACN_Decode(asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode angle */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angle)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_ANGLEAXISD_ANGLE;
	if (ret) {
	    /*Decode axis */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_ANGLEAXISD_AXIS;
	    pVal->axis.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->axis.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_ANGLEAXISD_AXIS_ELM;
	    }
	}

    return ret && asn1SccWrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Vector2d_data_Initialize(asn1SccWrappers_Vector2d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 2) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Vector2d_Initialize(asn1SccWrappers_Vector2d* pVal)
{


	/*set data */
	asn1SccWrappers_Vector2d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Vector2d_IsConstraintValid(const asn1SccWrappers_Vector2d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Vector2d_Encode(const asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector2d_Decode(asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Vector2d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Vector2d_ACN_Encode(const asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector2d_ACN_Decode(asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR2D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Vector2d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Pose2D_Initialize(asn1SccBase_Pose2D* pVal)
{


	/*set position */
	asn1SccWrappers_Vector2d_Initialize((&(pVal->position)));
	/*set orientation */
	asn1SccT_Double_Initialize((&(pVal->orientation)));
}

flag asn1SccBase_Pose2D_IsConstraintValid(const asn1SccBase_Pose2D *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_ORIENTATION;
    }

	return ret;
}

flag asn1SccBase_Pose2D_Encode(const asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccT_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose2D_Decode(asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccT_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Pose2D_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Pose2D_ACN_Encode(const asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        BitStream_EncodeReal(pBitStrm, pVal->orientation);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose2D_ACN_Decode(asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_ORIENTATION;
	}

    return ret && asn1SccBase_Pose2D_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Pose2D_m_Initialize(asn1SccBase_Pose2D_m* pVal)
{


	/*set position */
	asn1SccWrappers_Vector2d_Initialize((&(pVal->position)));
	/*set orientation */
	asn1SccT_Double_Initialize((&(pVal->orientation)));
}

flag asn1SccBase_Pose2D_m_IsConstraintValid(const asn1SccBase_Pose2D_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_ORIENTATION;
    }

	return ret;
}

flag asn1SccBase_Pose2D_m_Encode(const asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccT_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose2D_m_Decode(asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccT_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Pose2D_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Pose2D_m_ACN_Encode(const asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        BitStream_EncodeReal(pBitStrm, pVal->orientation);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose2D_m_ACN_Decode(asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_M_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_M_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE2D_M_ORIENTATION;
	}

    return ret && asn1SccBase_Pose2D_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Matrix2d_data_Initialize(asn1SccWrappers_Matrix2d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Matrix2d_Initialize(asn1SccWrappers_Matrix2d* pVal)
{


	/*set data */
	asn1SccWrappers_Matrix2d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Matrix2d_IsConstraintValid(const asn1SccWrappers_Matrix2d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Matrix2d_Encode(const asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix2d_Decode(asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Matrix2d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Matrix2d_ACN_Encode(const asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix2d_ACN_Decode(asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX2D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Matrix2d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Vector3d_data_Initialize(asn1SccWrappers_Vector3d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Vector3d_Initialize(asn1SccWrappers_Vector3d* pVal)
{


	/*set data */
	asn1SccWrappers_Vector3d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Vector3d_IsConstraintValid(const asn1SccWrappers_Vector3d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Vector3d_Encode(const asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector3d_Decode(asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Vector3d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Vector3d_ACN_Encode(const asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector3d_ACN_Decode(asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR3D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Vector3d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Wrench_Initialize(asn1SccBase_Wrench* pVal)
{


	/*set force */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->torque)));
}

flag asn1SccBase_Wrench_IsConstraintValid(const asn1SccBase_Wrench *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA;
    for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA;
        for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA_ELM;
        }

    }

	return ret;
}

flag asn1SccBase_Wrench_Encode(const asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Wrench_Decode(asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Wrench_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Wrench_ACN_Encode(const asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->force.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->force.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode torque */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->torque.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->torque.data.arr[i1]);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Wrench_ACN_Decode(asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode force */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_FORCE_DATA;
	pVal->force.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->force.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_FORCE_DATA_ELM;
	}
	if (ret) {
	    /*Decode torque */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_TORQUE_DATA;
	    pVal->torque.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->torque.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_TORQUE_DATA_ELM;
	    }
	}

    return ret && asn1SccBase_Wrench_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Waypoint_Initialize(asn1SccBase_Waypoint* pVal)
{


	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set heading */
	asn1SccT_Double_Initialize((&(pVal->heading)));
	/*set tol_position */
	asn1SccT_Double_Initialize((&(pVal->tol_position)));
	/*set tol_heading */
	asn1SccT_Double_Initialize((&(pVal->tol_heading)));
}

flag asn1SccBase_Waypoint_IsConstraintValid(const asn1SccBase_Waypoint *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_HEADING;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_POSITION;
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_HEADING;
            }
        }
    }

	return ret;
}

flag asn1SccBase_Waypoint_Encode(const asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Waypoint_Decode(asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = asn1SccT_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = asn1SccT_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = asn1SccT_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_Waypoint_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Waypoint_ACN_Encode(const asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode heading */
	        BitStream_EncodeReal(pBitStrm, pVal->heading);
	        if (ret) {
	            /*Encode tol_position */
	            BitStream_EncodeReal(pBitStrm, pVal->tol_position);
	            if (ret) {
	                /*Encode tol_heading */
	                BitStream_EncodeReal(pBitStrm, pVal->tol_heading);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Waypoint_ACN_Decode(asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode heading */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heading)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_HEADING;
	    if (ret) {
	        /*Decode tol_position */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->tol_position)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_TOL_POSITION;
	        if (ret) {
	            /*Decode tol_heading */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->tol_heading)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_TOL_HEADING;
	        }
	    }
	}

    return ret && asn1SccBase_Waypoint_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Waypoint_m_Initialize(asn1SccBase_Waypoint_m* pVal)
{


	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set heading */
	asn1SccT_Double_Initialize((&(pVal->heading)));
	/*set tol_position */
	asn1SccT_Double_Initialize((&(pVal->tol_position)));
	/*set tol_heading */
	asn1SccT_Double_Initialize((&(pVal->tol_heading)));
}

flag asn1SccBase_Waypoint_m_IsConstraintValid(const asn1SccBase_Waypoint_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_HEADING;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_POSITION;
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_HEADING;
            }
        }
    }

	return ret;
}

flag asn1SccBase_Waypoint_m_Encode(const asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Waypoint_m_Decode(asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = asn1SccT_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = asn1SccT_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = asn1SccT_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_Waypoint_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Waypoint_m_ACN_Encode(const asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode heading */
	        BitStream_EncodeReal(pBitStrm, pVal->heading);
	        if (ret) {
	            /*Encode tol_position */
	            BitStream_EncodeReal(pBitStrm, pVal->tol_position);
	            if (ret) {
	                /*Encode tol_heading */
	                BitStream_EncodeReal(pBitStrm, pVal->tol_heading);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Waypoint_m_ACN_Decode(asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_M_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_M_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode heading */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heading)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_M_HEADING;
	    if (ret) {
	        /*Decode tol_position */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->tol_position)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_M_TOL_POSITION;
	        if (ret) {
	            /*Decode tol_heading */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->tol_heading)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WAYPOINT_M_TOL_HEADING;
	        }
	    }
	}

    return ret && asn1SccBase_Waypoint_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Waypoint_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((1 <= pVal->arr[i1].position.data.nCount) && (pVal->arr[i1].position.data.nCount <= 3));
    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA;
    	for(i2 = 0; ret && i2 < pVal->arr[i1].position.data.nCount; i2++) 
    	{
    		ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position.data.arr[i2]) && (pVal->arr[i1].position.data.arr[i2] <= 1.79769313486231570000E+308));
    		*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM;
    	}

    	if (ret) {
    	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].heading) && (pVal->arr[i1].heading <= 1.79769313486231570000E+308));
    	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING;
    	    if (ret) {
    	        ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_position) && (pVal->arr[i1].tol_position <= 1.79769313486231570000E+308));
    	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION;
    	        if (ret) {
    	            ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_heading) && (pVal->arr[i1].tol_heading <= 1.79769313486231570000E+308));
    	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING;
    	        }
    	    }
    	}
    }


	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Waypoint_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Waypoint_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_ACN_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode position */
	    	/*Encode data */
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].position.data.nCount, 1, 3);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].position.data.nCount) && ret; i2++) 
	    	{
	    		BitStream_EncodeReal(pBitStrm, pVal->arr[i1].position.data.arr[i2]);
	    	}
	    	if (ret) {
	    	    /*Encode heading */
	    	    BitStream_EncodeReal(pBitStrm, pVal->arr[i1].heading);
	    	    if (ret) {
	    	        /*Encode tol_position */
	    	        BitStream_EncodeReal(pBitStrm, pVal->arr[i1].tol_position);
	    	        if (ret) {
	    	            /*Encode tol_heading */
	    	            BitStream_EncodeReal(pBitStrm, pVal->arr[i1].tol_heading);
	    	        }
	    	    }
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_ACN_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode position */
		/*Decode data */
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA;
		pVal->arr[i1].position.data.nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].position.data.nCount) && ret; i2++) 
		{
			ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].position.data.arr[i2])));
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM;
		}
		if (ret) {
		    /*Decode heading */
		    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].heading)));
		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING;
		    if (ret) {
		        /*Decode tol_position */
		        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].tol_position)));
		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION;
		        if (ret) {
		            /*Decode tol_heading */
		            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].tol_heading)));
		            *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING;
		        }
		    }
		}
	}

    return ret && asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Wrench_m_Initialize(asn1SccBase_Wrench_m* pVal)
{


	/*set force */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->torque)));
}

flag asn1SccBase_Wrench_m_IsConstraintValid(const asn1SccBase_Wrench_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA;
    for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA;
        for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA_ELM;
        }

    }

	return ret;
}

flag asn1SccBase_Wrench_m_Encode(const asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Wrench_m_Decode(asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Wrench_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Wrench_m_ACN_Encode(const asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->force.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->force.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode torque */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->torque.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->torque.data.arr[i1]);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Wrench_m_ACN_Decode(asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode force */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_M_FORCE_DATA;
	pVal->force.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->force.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_M_FORCE_DATA_ELM;
	}
	if (ret) {
	    /*Decode torque */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_M_TORQUE_DATA;
	    pVal->torque.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->torque.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_WRENCH_M_TORQUE_DATA_ELM;
	    }
	}

    return ret && asn1SccBase_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Wrench_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((1 <= pVal->arr[i1].force.data.nCount) && (pVal->arr[i1].force.data.nCount <= 3));
    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA;
    	for(i2 = 0; ret && i2 < pVal->arr[i1].force.data.nCount; i2++) 
    	{
    		ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].force.data.arr[i2]) && (pVal->arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
    		*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM;
    	}

    	if (ret) {
    	    ret = ((1 <= pVal->arr[i1].torque.data.nCount) && (pVal->arr[i1].torque.data.nCount <= 3));
    	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA;
    	    for(i2 = 0; ret && i2 < pVal->arr[i1].torque.data.nCount; i2++) 
    	    {
    	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].torque.data.arr[i2]) && (pVal->arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
    	    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM;
    	    }

    	}
    }


	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Wrench_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_ACN_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode force */
	    	/*Encode data */
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].force.data.nCount, 1, 3);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].force.data.nCount) && ret; i2++) 
	    	{
	    		BitStream_EncodeReal(pBitStrm, pVal->arr[i1].force.data.arr[i2]);
	    	}
	    	if (ret) {
	    	    /*Encode torque */
	    	    /*Encode data */
	    	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].torque.data.nCount, 1, 3);
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->arr[i1].torque.data.nCount) && ret; i2++) 
	    	    {
	    	    	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].torque.data.arr[i2]);
	    	    }
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_ACN_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode force */
		/*Decode data */
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA;
		pVal->arr[i1].force.data.nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].force.data.nCount) && ret; i2++) 
		{
			ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].force.data.arr[i2])));
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM;
		}
		if (ret) {
		    /*Decode torque */
		    /*Decode data */
		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA;
		    pVal->arr[i1].torque.data.nCount = (long)nCount;
		    	
		    for(i2=0; (i2 < (int)pVal->arr[i1].torque.data.nCount) && ret; i2++) 
		    {
		    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].torque.data.arr[i2])));
		    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM;
		    }
		}
	}

    return ret && asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Matrix3d_data_Initialize(asn1SccWrappers_Matrix3d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 9) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Matrix3d_Initialize(asn1SccWrappers_Matrix3d* pVal)
{


	/*set data */
	asn1SccWrappers_Matrix3d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Matrix3d_IsConstraintValid(const asn1SccWrappers_Matrix3d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 9));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Matrix3d_Encode(const asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 9);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix3d_Decode(asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Matrix3d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Matrix3d_ACN_Encode(const asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 9);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix3d_ACN_Decode(asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX3D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Matrix3d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Vector4d_data_Initialize(asn1SccWrappers_Vector4d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Vector4d_Initialize(asn1SccWrappers_Vector4d* pVal)
{


	/*set data */
	asn1SccWrappers_Vector4d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Vector4d_IsConstraintValid(const asn1SccWrappers_Vector4d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Vector4d_Encode(const asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector4d_Decode(asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Vector4d_ACN_Encode(const asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector4d_ACN_Decode(asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR4D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccStd_vector_Wrappers_Vector4d_Initialize(asn1SccStd_vector_Wrappers_Vector4d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccWrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(const asn1SccStd_vector_Wrappers_Vector4d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((1 <= pVal->arr[i1].data.nCount) && (pVal->arr[i1].data.nCount <= 4));
    	*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA;
    	for(i2 = 0; ret && i2 < pVal->arr[i1].data.nCount; i2++) 
    	{
    		ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].data.arr[i2]) && (pVal->arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
    		*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM;
    	}

    }


	return ret;
}

flag asn1SccStd_vector_Wrappers_Vector4d_Encode(const asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector4d_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccStd_vector_Wrappers_Vector4d_Decode(asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector4d_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccStd_vector_Wrappers_Vector4d_ACN_Encode(const asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode data */
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].data.nCount, 1, 4);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].data.nCount) && ret; i2++) 
	    	{
	    		BitStream_EncodeReal(pBitStrm, pVal->arr[i1].data.arr[i2]);
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccStd_vector_Wrappers_Vector4d_ACN_Decode(asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode data */
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA;
		pVal->arr[i1].data.nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].data.nCount) && ret; i2++) 
		{
			ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].data.arr[i2])));
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM;
		}
	}

    return ret && asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Matrix4d_data_Initialize(asn1SccWrappers_Matrix4d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 16) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Matrix4d_Initialize(asn1SccWrappers_Matrix4d* pVal)
{


	/*set data */
	asn1SccWrappers_Matrix4d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Matrix4d_IsConstraintValid(const asn1SccWrappers_Matrix4d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 16));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Matrix4d_Encode(const asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix4d_Decode(asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Matrix4d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Matrix4d_ACN_Encode(const asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix4d_ACN_Decode(asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX4D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Matrix4d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Vector6d_data_Initialize(asn1SccWrappers_Vector6d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 6) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Vector6d_Initialize(asn1SccWrappers_Vector6d* pVal)
{


	/*set data */
	asn1SccWrappers_Vector6d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Vector6d_IsConstraintValid(const asn1SccWrappers_Vector6d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 6));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Vector6d_Encode(const asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector6d_Decode(asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Vector6d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Vector6d_ACN_Encode(const asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Vector6d_ACN_Decode(asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTOR6D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Vector6d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Matrix6d_data_Initialize(asn1SccWrappers_Matrix6d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 36) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Matrix6d_Initialize(asn1SccWrappers_Matrix6d* pVal)
{


	/*set data */
	asn1SccWrappers_Matrix6d_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_Matrix6d_IsConstraintValid(const asn1SccWrappers_Matrix6d *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 36));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_Matrix6d_Encode(const asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 36);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix6d_Decode(asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Matrix6d_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Matrix6d_ACN_Encode(const asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 36);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Matrix6d_ACN_Decode(asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIX6D_DATA_ELM;
	}

    return ret && asn1SccWrappers_Matrix6d_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_TwistWithCovariance_Initialize(asn1SccBase_TwistWithCovariance* pVal)
{


	/*set vel */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->vel)));
	/*set rot */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->rot)));
	/*set cov */
	asn1SccWrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag asn1SccBase_TwistWithCovariance_IsConstraintValid(const asn1SccBase_TwistWithCovariance *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA;
    for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA;
        for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA;
            for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_TwistWithCovariance_Encode(const asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TwistWithCovariance_Decode(asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_TwistWithCovariance_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_TwistWithCovariance_ACN_Encode(const asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vel.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->vel.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->vel.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode rot */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->rot.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->rot.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->rot.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode cov */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov.data.nCount, 1, 36);
	            	
	            for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TwistWithCovariance_ACN_Decode(asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode vel */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_VEL_DATA;
	pVal->vel.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->vel.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->vel.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM;
	}
	if (ret) {
	    /*Decode rot */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_ROT_DATA;
	    pVal->rot.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->rot.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rot.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode cov */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_COV_DATA;
	        pVal->cov.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_TwistWithCovariance_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_TwistWithCovariance_m_Initialize(asn1SccBase_TwistWithCovariance_m* pVal)
{


	/*set vel */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->vel)));
	/*set rot */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->rot)));
	/*set cov */
	asn1SccWrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag asn1SccBase_TwistWithCovariance_m_IsConstraintValid(const asn1SccBase_TwistWithCovariance_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA;
    for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA;
        for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA;
            for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_TwistWithCovariance_m_Encode(const asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TwistWithCovariance_m_Decode(asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_TwistWithCovariance_m_ACN_Encode(const asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vel.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->vel.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->vel.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode rot */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->rot.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->rot.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->rot.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode cov */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov.data.nCount, 1, 36);
	            	
	            for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TwistWithCovariance_m_ACN_Decode(asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode vel */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA;
	pVal->vel.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->vel.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->vel.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM;
	}
	if (ret) {
	    /*Decode rot */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA;
	    pVal->rot.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->rot.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rot.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode cov */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_COV_DATA;
	        pVal->cov.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_MatrixXd_data_Initialize(asn1SccWrappers_MatrixXd_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_MatrixXd_Initialize(asn1SccWrappers_MatrixXd* pVal)
{


	/*set rows */
	asn1SccT_Int32_Initialize((&(pVal->rows)));
	/*set cols */
	asn1SccT_Int32_Initialize((&(pVal->cols)));
	/*set data */
	asn1SccWrappers_MatrixXd_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_MatrixXd_IsConstraintValid(const asn1SccWrappers_MatrixXd *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-2147483648LL <= pVal->rows) && (pVal->rows <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_ROWS;
    if (ret) {
        ret = ((-2147483648LL <= pVal->cols) && (pVal->cols <= 2147483647LL));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_COLS;
        if (ret) {
            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA;
            for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccWrappers_MatrixXd_Encode(const asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rows */
	    ret = asn1SccT_Int32_Encode((&(pVal->rows)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cols */
	        ret = asn1SccT_Int32_Encode((&(pVal->cols)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_MatrixXd_Decode(asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode rows */
	ret = asn1SccT_Int32_Decode((&(pVal->rows)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cols */
	    ret = asn1SccT_Int32_Decode((&(pVal->cols)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA;
	        pVal->data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccWrappers_MatrixXd_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_MatrixXd_ACN_Encode(const asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rows */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->rows, -2147483648LL, 2147483647LL);
	    if (ret) {
	        /*Encode cols */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cols, -2147483648LL, 2147483647LL);
	        if (ret) {
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_MatrixXd_ACN_Decode(asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode rows */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->rows)), -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIXXD_ROWS;
	if (ret) {
	    /*Decode cols */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->cols)), -2147483648LL, 2147483647LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIXXD_COLS;
	    if (ret) {
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIXXD_DATA;
	        pVal->data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_MATRIXXD_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccWrappers_MatrixXd_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_Quaterniond_im_Initialize(asn1SccWrappers_Quaterniond_im* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_Quaterniond_Initialize(asn1SccWrappers_Quaterniond* pVal)
{


	/*set im */
	asn1SccWrappers_Quaterniond_im_Initialize((&(pVal->im)));
	/*set re */
	asn1SccT_Double_Initialize((&(pVal->re)));
}

flag asn1SccWrappers_Quaterniond_IsConstraintValid(const asn1SccWrappers_Quaterniond *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->im.nCount) && (pVal->im.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM;
    for(i1 = 0; ret && i1 < pVal->im.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->im.arr[i1]) && (pVal->im.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM_ELM;
    }

    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->re) && (pVal->re <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_RE;
    }

	return ret;
}

flag asn1SccWrappers_Quaterniond_Encode(const asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode im */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->im.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->im.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode re */
	        ret = asn1SccT_Double_Encode((&(pVal->re)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Quaterniond_Decode(asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode im */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM;
	pVal->im.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->im.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode re */
	    ret = asn1SccT_Double_Decode((&(pVal->re)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_Quaterniond_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_Quaterniond_ACN_Encode(const asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode im */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->im.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->im.arr[i1]);
	    }
	    if (ret) {
	        /*Encode re */
	        BitStream_EncodeReal(pBitStrm, pVal->re);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_Quaterniond_ACN_Decode(asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode im */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_QUATERNIOND_IM;
	pVal->im.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->im.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_QUATERNIOND_IM_ELM;
	}
	if (ret) {
	    /*Decode re */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->re)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_QUATERNIOND_RE;
	}

    return ret && asn1SccWrappers_Quaterniond_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Pose_Initialize(asn1SccBase_Pose* pVal)
{


	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
}

flag asn1SccBase_Pose_IsConstraintValid(const asn1SccBase_Pose *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM;
        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM_ELM;
        }

        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_RE;
        }
    }

	return ret;
}

flag asn1SccBase_Pose_Encode(const asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose_Decode(asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Pose_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Pose_ACN_Encode(const asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        /*Encode im */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	        }
	        if (ret) {
	            /*Encode re */
	            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose_ACN_Decode(asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    /*Decode im */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_ORIENTATION_IM;
	    pVal->orientation.im.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_ORIENTATION_IM_ELM;
	    }
	    if (ret) {
	        /*Decode re */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_ORIENTATION_RE;
	    }
	}

    return ret && asn1SccBase_Pose_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_TransformWithCovariance_Initialize(asn1SccBase_TransformWithCovariance* pVal)
{


	/*set translation */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->translation)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov */
	asn1SccWrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag asn1SccBase_TransformWithCovariance_IsConstraintValid(const asn1SccBase_TransformWithCovariance *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA;
    for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM;
        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM;
        }

        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE;
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA;
            for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_TransformWithCovariance_Encode(const asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TransformWithCovariance_Decode(asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_TransformWithCovariance_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_TransformWithCovariance_ACN_Encode(const asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->translation.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->translation.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->translation.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        /*Encode im */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	        }
	        if (ret) {
	            /*Encode re */
	            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	        }
	        if (ret) {
	            /*Encode cov */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov.data.nCount, 1, 36);
	            	
	            for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TransformWithCovariance_ACN_Decode(asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode translation */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA;
	pVal->translation.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->translation.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->translation.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    /*Decode im */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM;
	    pVal->orientation.im.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM;
	    }
	    if (ret) {
	        /*Decode re */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE;
	    }
	    if (ret) {
	        /*Decode cov */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA;
	        pVal->cov.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_TransformWithCovariance_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Pose_m_Initialize(asn1SccBase_Pose_m* pVal)
{


	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
}

flag asn1SccBase_Pose_m_IsConstraintValid(const asn1SccBase_Pose_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA;
    for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM;
        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM_ELM;
        }

        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_RE;
        }
    }

	return ret;
}

flag asn1SccBase_Pose_m_Encode(const asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose_m_Decode(asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Pose_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Pose_m_ACN_Encode(const asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        /*Encode im */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	        }
	        if (ret) {
	            /*Encode re */
	            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Pose_m_ACN_Decode(asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode position */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_M_POSITION_DATA;
	pVal->position.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_M_POSITION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    /*Decode im */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_M_ORIENTATION_IM;
	    pVal->orientation.im.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_M_ORIENTATION_IM_ELM;
	    }
	    if (ret) {
	        /*Decode re */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_POSE_M_ORIENTATION_RE;
	    }
	}

    return ret && asn1SccBase_Pose_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_TransformWithCovariance_m_Initialize(asn1SccBase_TransformWithCovariance_m* pVal)
{


	/*set translation */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->translation)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov */
	asn1SccWrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag asn1SccBase_TransformWithCovariance_m_IsConstraintValid(const asn1SccBase_TransformWithCovariance_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA;
    for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM;
        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM;
        }

        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE;
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA;
            for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_TransformWithCovariance_m_Encode(const asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TransformWithCovariance_m_Decode(asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_TransformWithCovariance_m_ACN_Encode(const asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->translation.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->translation.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->translation.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode orientation */
	        /*Encode im */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	        }
	        if (ret) {
	            /*Encode re */
	            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	        }
	        if (ret) {
	            /*Encode cov */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov.data.nCount, 1, 36);
	            	
	            for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TransformWithCovariance_m_ACN_Decode(asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode translation */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA;
	pVal->translation.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->translation.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->translation.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM;
	}
	if (ret) {
	    /*Decode orientation */
	    /*Decode im */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM;
	    pVal->orientation.im.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM;
	    }
	    if (ret) {
	        /*Decode re */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE;
	    }
	    if (ret) {
	        /*Decode cov */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA;
	        pVal->cov.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_VectorXd_data_Initialize(asn1SccWrappers_VectorXd_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_VectorXd_Initialize(asn1SccWrappers_VectorXd* pVal)
{


	/*set data */
	asn1SccWrappers_VectorXd_data_Initialize((&(pVal->data)));
}

flag asn1SccWrappers_VectorXd_IsConstraintValid(const asn1SccWrappers_VectorXd *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA;
    for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA_ELM;
    }


	return ret;
}

flag asn1SccWrappers_VectorXd_Encode(const asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_VectorXd_Decode(asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccWrappers_VectorXd_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_VectorXd_ACN_Encode(const asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_VectorXd_ACN_Decode(asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTORXD_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_VECTORXD_DATA_ELM;
	}

    return ret && asn1SccWrappers_VectorXd_IsConstraintValid(pVal, pErrCode);
}



void asn1SccWrappers_geometry_Spline_knots_Initialize(asn1SccWrappers_geometry_Spline_knots* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_geometry_Spline_vertices_Initialize(asn1SccWrappers_geometry_Spline_vertices* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccWrappers_geometry_Spline_Initialize(asn1SccWrappers_geometry_Spline* pVal)
{


	/*set geometric_resolution */
	asn1SccT_Double_Initialize((&(pVal->geometric_resolution)));
	/*set dimension */
	asn1SccT_Int32_Initialize((&(pVal->dimension)));
	/*set curve_order */
	asn1SccT_Int32_Initialize((&(pVal->curve_order)));
	/*set kind */
	asn1SccWrappers_geometry_SplineType_Initialize((&(pVal->kind)));
	/*set knots */
	asn1SccWrappers_geometry_Spline_knots_Initialize((&(pVal->knots)));
	/*set vertices */
	asn1SccWrappers_geometry_Spline_vertices_Initialize((&(pVal->vertices)));
}

flag asn1SccWrappers_geometry_Spline_IsConstraintValid(const asn1SccWrappers_geometry_Spline *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->geometric_resolution) && (pVal->geometric_resolution <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION;
    if (ret) {
        ret = ((-2147483648LL <= pVal->dimension) && (pVal->dimension <= 2147483647LL));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION;
        if (ret) {
            ret = ((-2147483648LL <= pVal->curve_order) && (pVal->curve_order <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER;
            if (ret) {
                ret = (((((((((pVal->kind == asn1Sccwrappers_geometry_splinetype_degenerate)) || ((pVal->kind == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->kind == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->kind == asn1Sccwrappers_geometry_splinetype_rational_bezier)))) || ((pVal->kind == asn1Sccwrappers_geometry_splinetype_rational_bspline)));
                *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KIND;
                if (ret) {
                    ret = ((1 <= pVal->knots.nCount) && (pVal->knots.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
                    for(i1 = 0; ret && i1 < pVal->knots.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->knots.arr[i1]) && (pVal->knots.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM;
                    }

                    if (ret) {
                        ret = ((1 <= pVal->vertices.nCount) && (pVal->vertices.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
                        for(i1 = 0; ret && i1 < pVal->vertices.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->vertices.arr[i1]) && (pVal->vertices.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM;
                        }

                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccWrappers_geometry_Spline_Encode(const asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode geometric_resolution */
	    ret = asn1SccT_Double_Encode((&(pVal->geometric_resolution)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode dimension */
	        ret = asn1SccT_Int32_Encode((&(pVal->dimension)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode curve_order */
	            ret = asn1SccT_Int32_Encode((&(pVal->curve_order)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode kind */
	                ret = asn1SccWrappers_geometry_SplineType_Encode((&(pVal->kind)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode knots */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->knots.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccT_Double_Encode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode vertices */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertices.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                        {
	                        	ret = asn1SccT_Double_Encode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_geometry_Spline_Decode(asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode geometric_resolution */
	ret = asn1SccT_Double_Decode((&(pVal->geometric_resolution)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode dimension */
	    ret = asn1SccT_Int32_Decode((&(pVal->dimension)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode curve_order */
	        ret = asn1SccT_Int32_Decode((&(pVal->curve_order)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode kind */
	            ret = asn1SccWrappers_geometry_SplineType_Decode((&(pVal->kind)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode knots */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
	                pVal->knots.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                {
	                	ret = asn1SccT_Double_Decode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode vertices */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
	                    pVal->vertices.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccT_Double_Decode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode);
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccWrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWrappers_geometry_Spline_ACN_Encode(const asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	ret = bCheckConstraints ? asn1SccWrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode geometric_resolution */
	    BitStream_EncodeReal(pBitStrm, pVal->geometric_resolution);
	    if (ret) {
	        /*Encode dimension */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->dimension, -2147483648LL, 2147483647LL);
	        if (ret) {
	            /*Encode curve_order */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->curve_order, -2147483648LL, 2147483647LL);
	            if (ret) {
	                /*Encode kind */
	                switch(pVal->kind) { 
	                    case asn1Sccwrappers_geometry_splinetype_degenerate:
	                        intVal = 0;
	                        break;
	                    case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:
	                        intVal = 1;
	                        break;
	                    case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:
	                        intVal = 2;
	                        break;
	                    case asn1Sccwrappers_geometry_splinetype_rational_bezier:
	                        intVal = 3;
	                        break;
	                    case asn1Sccwrappers_geometry_splinetype_rational_bspline:
	                        intVal = 4;
	                        break;
	                    default:
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                }
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
	                if (ret) {
	                    /*Encode knots */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->knots.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->knots.arr[i1]);
	                    }
	                    if (ret) {
	                        /*Encode vertices */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertices.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->vertices.arr[i1]);
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccWrappers_geometry_Spline_ACN_Decode(asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	asn1SccSint nCount;

	/*Decode geometric_resolution */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->geometric_resolution)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION;
	if (ret) {
	    /*Decode dimension */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->dimension)), -2147483648LL, 2147483647LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_DIMENSION;
	    if (ret) {
	        /*Decode curve_order */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->curve_order)), -2147483648LL, 2147483647LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER;
	        if (ret) {
	            /*Decode kind */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 4);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_KIND;
	            if (ret) {
	                switch (intVal) {
	                    case 0:
	                        pVal->kind = asn1Sccwrappers_geometry_splinetype_degenerate;
	                        break;
	                    case 1:
	                        pVal->kind = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	                        break;
	                    case 2:
	                        pVal->kind = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	                        break;
	                    case 3:
	                        pVal->kind = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	                        break;
	                    case 4:
	                        pVal->kind = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	                        break;
	                default:
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                }
	            }
	            if (ret) {
	                /*Decode knots */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
	                pVal->knots.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->knots.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM;
	                }
	                if (ret) {
	                    /*Decode vertices */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
	                    pVal->vertices.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->vertices.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM;
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccWrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Trajectory_Initialize(asn1SccBase_Trajectory* pVal)
{


	/*set speed */
	asn1SccT_Double_Initialize((&(pVal->speed)));
	/*set spline */
	asn1SccWrappers_geometry_Spline_Initialize((&(pVal->spline)));
}

flag asn1SccBase_Trajectory_IsConstraintValid(const asn1SccBase_Trajectory *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPEED;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION;
        if (ret) {
            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_DIMENSION;
            if (ret) {
                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER;
                if (ret) {
                    ret = (((((((((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bspline)));
                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KIND;
                    if (ret) {
                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS;
                        for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM;
                        }

                        if (ret) {
                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES;
                            for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM;
                            }

                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_Trajectory_Encode(const asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = asn1SccT_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = asn1SccWrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Trajectory_Decode(asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = asn1SccT_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = asn1SccWrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Trajectory_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Trajectory_ACN_Encode(const asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    BitStream_EncodeReal(pBitStrm, pVal->speed);
	    if (ret) {
	        /*Encode spline */
	        /*Encode geometric_resolution */
	        BitStream_EncodeReal(pBitStrm, pVal->spline.geometric_resolution);
	        if (ret) {
	            /*Encode dimension */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.dimension, -2147483648LL, 2147483647LL);
	            if (ret) {
	                /*Encode curve_order */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.curve_order, -2147483648LL, 2147483647LL);
	                if (ret) {
	                    /*Encode kind */
	                    switch(pVal->spline.kind) { 
	                        case asn1Sccwrappers_geometry_splinetype_degenerate:
	                            intVal = 0;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:
	                            intVal = 1;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:
	                            intVal = 2;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_rational_bezier:
	                            intVal = 3;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_rational_bspline:
	                            intVal = 4;
	                            break;
	                        default:
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_ENCODE_BASE_TRAJECTORY_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                    }
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
	                    if (ret) {
	                        /*Encode knots */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.knots.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->spline.knots.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->spline.knots.arr[i1]);
	                        }
	                        if (ret) {
	                            /*Encode vertices */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.vertices.nCount, 1, 200);
	                            	
	                            for(i1=0; (i1 < (int)pVal->spline.vertices.nCount) && ret; i1++) 
	                            {
	                            	BitStream_EncodeReal(pBitStrm, pVal->spline.vertices.arr[i1]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Trajectory_ACN_Decode(asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	asn1SccSint nCount;

	/*Decode speed */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPEED;
	if (ret) {
	    /*Decode spline */
	    /*Decode geometric_resolution */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.geometric_resolution)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION;
	    if (ret) {
	        /*Decode dimension */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->spline.dimension)), -2147483648LL, 2147483647LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_DIMENSION;
	        if (ret) {
	            /*Decode curve_order */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->spline.curve_order)), -2147483648LL, 2147483647LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_CURVE_ORDER;
	            if (ret) {
	                /*Decode kind */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 4);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_KIND;
	                if (ret) {
	                    switch (intVal) {
	                        case 0:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_degenerate;
	                            break;
	                        case 1:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	                            break;
	                        case 2:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	                            break;
	                        case 3:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	                            break;
	                        case 4:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	                            break;
	                    default:
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                    }
	                }
	                if (ret) {
	                    /*Decode knots */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_KNOTS;
	                    pVal->spline.knots.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->spline.knots.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.knots.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_KNOTS_ELM;
	                    }
	                    if (ret) {
	                        /*Decode vertices */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_VERTICES;
	                        pVal->spline.vertices.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->spline.vertices.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.vertices.arr[i1])));
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_SPLINE_VERTICES_ELM;
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_Trajectory_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Trajectory_m_Initialize(asn1SccBase_Trajectory_m* pVal)
{


	/*set speed */
	asn1SccT_Double_Initialize((&(pVal->speed)));
	/*set spline */
	asn1SccWrappers_geometry_Spline_Initialize((&(pVal->spline)));
}

flag asn1SccBase_Trajectory_m_IsConstraintValid(const asn1SccBase_Trajectory_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPEED;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION;
        if (ret) {
            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION;
            if (ret) {
                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER;
                if (ret) {
                    ret = (((((((((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bspline)));
                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KIND;
                    if (ret) {
                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS;
                        for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM;
                        }

                        if (ret) {
                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES;
                            for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM;
                            }

                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_Trajectory_m_Encode(const asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = asn1SccT_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = asn1SccWrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_Trajectory_m_Decode(asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = asn1SccT_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = asn1SccWrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_Trajectory_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Trajectory_m_ACN_Encode(const asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    BitStream_EncodeReal(pBitStrm, pVal->speed);
	    if (ret) {
	        /*Encode spline */
	        /*Encode geometric_resolution */
	        BitStream_EncodeReal(pBitStrm, pVal->spline.geometric_resolution);
	        if (ret) {
	            /*Encode dimension */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.dimension, -2147483648LL, 2147483647LL);
	            if (ret) {
	                /*Encode curve_order */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.curve_order, -2147483648LL, 2147483647LL);
	                if (ret) {
	                    /*Encode kind */
	                    switch(pVal->spline.kind) { 
	                        case asn1Sccwrappers_geometry_splinetype_degenerate:
	                            intVal = 0;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:
	                            intVal = 1;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:
	                            intVal = 2;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_rational_bezier:
	                            intVal = 3;
	                            break;
	                        case asn1Sccwrappers_geometry_splinetype_rational_bspline:
	                            intVal = 4;
	                            break;
	                        default:
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_ENCODE_BASE_TRAJECTORY_M_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                    }
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
	                    if (ret) {
	                        /*Encode knots */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.knots.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->spline.knots.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->spline.knots.arr[i1]);
	                        }
	                        if (ret) {
	                            /*Encode vertices */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->spline.vertices.nCount, 1, 200);
	                            	
	                            for(i1=0; (i1 < (int)pVal->spline.vertices.nCount) && ret; i1++) 
	                            {
	                            	BitStream_EncodeReal(pBitStrm, pVal->spline.vertices.arr[i1]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_Trajectory_m_ACN_Decode(asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccUint intVal;
	int i1;
	asn1SccSint nCount;

	/*Decode speed */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPEED;
	if (ret) {
	    /*Decode spline */
	    /*Decode geometric_resolution */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.geometric_resolution)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION;
	    if (ret) {
	        /*Decode dimension */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->spline.dimension)), -2147483648LL, 2147483647LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_DIMENSION;
	        if (ret) {
	            /*Decode curve_order */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->spline.curve_order)), -2147483648LL, 2147483647LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER;
	            if (ret) {
	                /*Decode kind */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 4);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_KIND;
	                if (ret) {
	                    switch (intVal) {
	                        case 0:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_degenerate;
	                            break;
	                        case 1:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	                            break;
	                        case 2:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	                            break;
	                        case 3:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	                            break;
	                        case 4:
	                            pVal->spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	                            break;
	                    default:
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	                    }
	                }
	                if (ret) {
	                    /*Decode knots */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_KNOTS;
	                    pVal->spline.knots.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->spline.knots.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.knots.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM;
	                    }
	                    if (ret) {
	                        /*Decode vertices */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_VERTICES;
	                        pVal->spline.vertices.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->spline.vertices.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->spline.vertices.arr[i1])));
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM;
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_Trajectory_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Trajectory_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED;
    	if (ret) {
    	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.geometric_resolution) && (pVal->arr[i1].spline.geometric_resolution <= 1.79769313486231570000E+308));
    	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION;
    	    if (ret) {
    	        ret = ((-2147483648LL <= pVal->arr[i1].spline.dimension) && (pVal->arr[i1].spline.dimension <= 2147483647LL));
    	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION;
    	        if (ret) {
    	            ret = ((-2147483648LL <= pVal->arr[i1].spline.curve_order) && (pVal->arr[i1].spline.curve_order <= 2147483647LL));
    	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER;
    	            if (ret) {
    	                ret = (((((((((pVal->arr[i1].spline.kind == asn1Sccwrappers_geometry_splinetype_degenerate)) || ((pVal->arr[i1].spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->arr[i1].spline.kind == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->arr[i1].spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bezier)))) || ((pVal->arr[i1].spline.kind == asn1Sccwrappers_geometry_splinetype_rational_bspline)));
    	                *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;
    	                if (ret) {
    	                    ret = ((1 <= pVal->arr[i1].spline.knots.nCount) && (pVal->arr[i1].spline.knots.nCount <= 200));
    	                    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS;
    	                    for(i2 = 0; ret && i2 < pVal->arr[i1].spline.knots.nCount; i2++) 
    	                    {
    	                    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.knots.arr[i2]) && (pVal->arr[i1].spline.knots.arr[i2] <= 1.79769313486231570000E+308));
    	                    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM;
    	                    }

    	                    if (ret) {
    	                        ret = ((1 <= pVal->arr[i1].spline.vertices.nCount) && (pVal->arr[i1].spline.vertices.nCount <= 200));
    	                        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES;
    	                        for(i2 = 0; ret && i2 < pVal->arr[i1].spline.vertices.nCount; i2++) 
    	                        {
    	                        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.vertices.arr[i2]) && (pVal->arr[i1].spline.vertices.arr[i2] <= 1.79769313486231570000E+308));
    	                        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM;
    	                        }

    	                    }
    	                }
    	            }
    	        }
    	    }
    	}
    }


	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Trajectory_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Trajectory_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_ACN_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	asn1SccUint intVal;
	int i2;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode speed */
	    	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].speed);
	    	if (ret) {
	    	    /*Encode spline */
	    	    /*Encode geometric_resolution */
	    	    BitStream_EncodeReal(pBitStrm, pVal->arr[i1].spline.geometric_resolution);
	    	    if (ret) {
	    	        /*Encode dimension */
	    	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].spline.dimension, -2147483648LL, 2147483647LL);
	    	        if (ret) {
	    	            /*Encode curve_order */
	    	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].spline.curve_order, -2147483648LL, 2147483647LL);
	    	            if (ret) {
	    	                /*Encode kind */
	    	                switch(pVal->arr[i1].spline.kind) { 
	    	                    case asn1Sccwrappers_geometry_splinetype_degenerate:
	    	                        intVal = 0;
	    	                        break;
	    	                    case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:
	    	                        intVal = 1;
	    	                        break;
	    	                    case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:
	    	                        intVal = 2;
	    	                        break;
	    	                    case asn1Sccwrappers_geometry_splinetype_rational_bezier:
	    	                        intVal = 3;
	    	                        break;
	    	                    case asn1Sccwrappers_geometry_splinetype_rational_bspline:
	    	                        intVal = 4;
	    	                        break;
	    	                    default:
	    	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	    	                        *pErrCode = ERR_ACN_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
	    	                }
	    	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
	    	                if (ret) {
	    	                    /*Encode knots */
	    	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].spline.knots.nCount, 1, 200);
	    	                    	
	    	                    for(i2=0; (i2 < (int)pVal->arr[i1].spline.knots.nCount) && ret; i2++) 
	    	                    {
	    	                    	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].spline.knots.arr[i2]);
	    	                    }
	    	                    if (ret) {
	    	                        /*Encode vertices */
	    	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].spline.vertices.nCount, 1, 200);
	    	                        	
	    	                        for(i2=0; (i2 < (int)pVal->arr[i1].spline.vertices.nCount) && ret; i2++) 
	    	                        {
	    	                        	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].spline.vertices.arr[i2]);
	    	                        }
	    	                    }
	    	                }
	    	            }
	    	        }
	    	    }
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_ACN_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccUint intVal;
	int i2;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode speed */
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].speed)));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED;
		if (ret) {
		    /*Decode spline */
		    /*Decode geometric_resolution */
		    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].spline.geometric_resolution)));
		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION;
		    if (ret) {
		        /*Decode dimension */
		        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->arr[i1].spline.dimension)), -2147483648LL, 2147483647LL);
		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION;
		        if (ret) {
		            /*Decode curve_order */
		            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->arr[i1].spline.curve_order)), -2147483648LL, 2147483647LL);
		            *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER;
		            if (ret) {
		                /*Decode kind */
		                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 4);
		                *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;
		                if (ret) {
		                    switch (intVal) {
		                        case 0:
		                            pVal->arr[i1].spline.kind = asn1Sccwrappers_geometry_splinetype_degenerate;
		                            break;
		                        case 1:
		                            pVal->arr[i1].spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
		                            break;
		                        case 2:
		                            pVal->arr[i1].spline.kind = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
		                            break;
		                        case 3:
		                            pVal->arr[i1].spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bezier;
		                            break;
		                        case 4:
		                            pVal->arr[i1].spline.kind = asn1Sccwrappers_geometry_splinetype_rational_bspline;
		                            break;
		                    default:
		                        ret = FALSE;                            /*COVERAGE_IGNORE*/
		                        *pErrCode = ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;                 /*COVERAGE_IGNORE*/
		                    }
		                }
		                if (ret) {
		                    /*Decode knots */
		                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
		                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS;
		                    pVal->arr[i1].spline.knots.nCount = (long)nCount;
		                    	
		                    for(i2=0; (i2 < (int)pVal->arr[i1].spline.knots.nCount) && ret; i2++) 
		                    {
		                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].spline.knots.arr[i2])));
		                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM;
		                    }
		                    if (ret) {
		                        /*Decode vertices */
		                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
		                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES;
		                        pVal->arr[i1].spline.vertices.nCount = (long)nCount;
		                        	
		                        for(i2=0; (i2 < (int)pVal->arr[i1].spline.vertices.nCount) && ret; i2++) 
		                        {
		                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].spline.vertices.arr[i2])));
		                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM;
		                        }
		                    }
		                }
		            }
		        }
		    }
		}
	}

    return ret && asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode);
}



void asn1SccGeometry_msgs_Point_Initialize(asn1SccGeometry_msgs_Point* pVal)
{


	/*set x */
	asn1SccT_Double_Initialize((&(pVal->x)));
	/*set y */
	asn1SccT_Double_Initialize((&(pVal->y)));
	/*set z */
	asn1SccT_Double_Initialize((&(pVal->z)));
}

flag asn1SccGeometry_msgs_Point_IsConstraintValid(const asn1SccGeometry_msgs_Point *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->x) && (pVal->x <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT_X;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->y) && (pVal->y <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT_Y;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->z) && (pVal->z <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT_Z;
        }
    }

	return ret;
}

flag asn1SccGeometry_msgs_Point_Encode(const asn1SccGeometry_msgs_Point* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccGeometry_msgs_Point_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = asn1SccT_Double_Encode((&(pVal->x)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = asn1SccT_Double_Encode((&(pVal->y)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = asn1SccT_Double_Encode((&(pVal->z)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccGeometry_msgs_Point_Decode(asn1SccGeometry_msgs_Point* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = asn1SccT_Double_Decode((&(pVal->x)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y */
	    ret = asn1SccT_Double_Decode((&(pVal->y)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z */
	        ret = asn1SccT_Double_Decode((&(pVal->z)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccGeometry_msgs_Point_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccGeometry_msgs_Point_ACN_Encode(const asn1SccGeometry_msgs_Point* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccGeometry_msgs_Point_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    BitStream_EncodeReal(pBitStrm, pVal->x);
	    if (ret) {
	        /*Encode y */
	        BitStream_EncodeReal(pBitStrm, pVal->y);
	        if (ret) {
	            /*Encode z */
	            BitStream_EncodeReal(pBitStrm, pVal->z);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccGeometry_msgs_Point_ACN_Decode(asn1SccGeometry_msgs_Point* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->x)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT_X;
	if (ret) {
	    /*Decode y */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->y)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT_Y;
	    if (ret) {
	        /*Decode z */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->z)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT_Z;
	    }
	}

    return ret && asn1SccGeometry_msgs_Point_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{

	(*(pVal)) = 0.00000000000000000000E+000;
}

flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT;

	return ret;
}

flag asn1SccT_Float_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Float_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Float_ACN_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    }

	
    return ret;
}

flag asn1SccT_Float_ACN_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLOAT;

    return ret && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointState_Initialize(asn1SccBase_JointState* pVal)
{


	/*set position */
	asn1SccT_Double_Initialize((&(pVal->position)));
	/*set speed */
	asn1SccT_Float_Initialize((&(pVal->speed)));
	/*set effort */
	asn1SccT_Float_Initialize((&(pVal->effort)));
	/*set raw */
	asn1SccT_Float_Initialize((&(pVal->raw)));
	/*set acceleration */
	asn1SccT_Float_Initialize((&(pVal->acceleration)));
}

flag asn1SccBase_JointState_IsConstraintValid(const asn1SccBase_JointState *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->position) && (pVal->position <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_POSITION;
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->speed) && (pVal->speed <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_SPEED;
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->effort) && (pVal->effort <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_EFFORT;
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->raw) && (pVal->raw <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_RAW;
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->acceleration) && (pVal->acceleration <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_ACCELERATION;
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_JointState_Encode(const asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccT_Double_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode speed */
	        ret = asn1SccT_Float_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode effort */
	            ret = asn1SccT_Float_Encode((&(pVal->effort)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode raw */
	                ret = asn1SccT_Float_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode acceleration */
	                    ret = asn1SccT_Float_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointState_Decode(asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccT_Double_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode speed */
	    ret = asn1SccT_Float_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode effort */
	        ret = asn1SccT_Float_Decode((&(pVal->effort)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode raw */
	            ret = asn1SccT_Float_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode acceleration */
	                ret = asn1SccT_Float_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_JointState_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointState_ACN_Encode(const asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    BitStream_EncodeReal(pBitStrm, pVal->position);
	    if (ret) {
	        /*Encode speed */
	        BitStream_EncodeReal(pBitStrm, pVal->speed);
	        if (ret) {
	            /*Encode effort */
	            BitStream_EncodeReal(pBitStrm, pVal->effort);
	            if (ret) {
	                /*Encode raw */
	                BitStream_EncodeReal(pBitStrm, pVal->raw);
	                if (ret) {
	                    /*Encode acceleration */
	                    BitStream_EncodeReal(pBitStrm, pVal->acceleration);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointState_ACN_Decode(asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_POSITION;
	if (ret) {
	    /*Decode speed */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_SPEED;
	    if (ret) {
	        /*Decode effort */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->effort)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_EFFORT;
	        if (ret) {
	            /*Decode raw */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->raw)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_RAW;
	            if (ret) {
	                /*Decode acceleration */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->acceleration)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTATE_ACCELERATION;
	            }
	        }
	    }
	}

    return ret && asn1SccBase_JointState_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointTrajectory_Initialize(asn1SccBase_JointTrajectory* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointState_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccBase_JointTrajectory_IsConstraintValid(const asn1SccBase_JointTrajectory *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position) && (pVal->arr[i1].position <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_POSITION;
    	if (ret) {
    	    ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 3.40282346600000020000E+038));
    	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_SPEED;
    	    if (ret) {
    	        ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].effort) && (pVal->arr[i1].effort <= 3.40282346600000020000E+038));
    	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT;
    	        if (ret) {
    	            ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].raw) && (pVal->arr[i1].raw <= 3.40282346600000020000E+038));
    	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_RAW;
    	            if (ret) {
    	                ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].acceleration) && (pVal->arr[i1].acceleration <= 3.40282346600000020000E+038));
    	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION;
    	            }
    	        }
    	    }
    	}
    }


	return ret;
}

flag asn1SccBase_JointTrajectory_Encode(const asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointState_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTrajectory_Decode(asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointState_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointTrajectory_ACN_Encode(const asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode position */
	    	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].position);
	    	if (ret) {
	    	    /*Encode speed */
	    	    BitStream_EncodeReal(pBitStrm, pVal->arr[i1].speed);
	    	    if (ret) {
	    	        /*Encode effort */
	    	        BitStream_EncodeReal(pBitStrm, pVal->arr[i1].effort);
	    	        if (ret) {
	    	            /*Encode raw */
	    	            BitStream_EncodeReal(pBitStrm, pVal->arr[i1].raw);
	    	            if (ret) {
	    	                /*Encode acceleration */
	    	                BitStream_EncodeReal(pBitStrm, pVal->arr[i1].acceleration);
	    	            }
	    	        }
	    	    }
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTrajectory_ACN_Decode(asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode position */
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].position)));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY_ELM_POSITION;
		if (ret) {
		    /*Decode speed */
		    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].speed)));
		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY_ELM_SPEED;
		    if (ret) {
		        /*Decode effort */
		        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].effort)));
		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY_ELM_EFFORT;
		        if (ret) {
		            /*Decode raw */
		            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].raw)));
		            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY_ELM_RAW;
		            if (ret) {
		                /*Decode acceleration */
		                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].acceleration)));
		                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRAJECTORY_ELM_ACCELERATION;
		            }
		        }
		    }
		}
	}

    return ret && asn1SccBase_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointLimitRange_Initialize(asn1SccBase_JointLimitRange* pVal)
{


	/*set min */
	asn1SccBase_JointState_Initialize((&(pVal->min)));
	/*set max */
	asn1SccBase_JointState_Initialize((&(pVal->max)));
}

flag asn1SccBase_JointLimitRange_IsConstraintValid(const asn1SccBase_JointLimitRange *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->min.position) && (pVal->min.position <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_POSITION;
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->min.speed) && (pVal->min.speed <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_SPEED;
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->min.effort) && (pVal->min.effort <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT;
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->min.raw) && (pVal->min.raw <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_RAW;
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->min.acceleration) && (pVal->min.acceleration <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION;
                }
            }
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->max.position) && (pVal->max.position <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_POSITION;
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->max.speed) && (pVal->max.speed <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_SPEED;
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->max.effort) && (pVal->max.effort <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT;
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->max.raw) && (pVal->max.raw <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_RAW;
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->max.acceleration) && (pVal->max.acceleration <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION;
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_JointLimitRange_Encode(const asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    ret = asn1SccBase_JointState_Encode((&(pVal->min)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max */
	        ret = asn1SccBase_JointState_Encode((&(pVal->max)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointLimitRange_Decode(asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min */
	ret = asn1SccBase_JointState_Decode((&(pVal->min)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max */
	    ret = asn1SccBase_JointState_Decode((&(pVal->max)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointLimitRange_ACN_Encode(const asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    /*Encode position */
	    BitStream_EncodeReal(pBitStrm, pVal->min.position);
	    if (ret) {
	        /*Encode speed */
	        BitStream_EncodeReal(pBitStrm, pVal->min.speed);
	        if (ret) {
	            /*Encode effort */
	            BitStream_EncodeReal(pBitStrm, pVal->min.effort);
	            if (ret) {
	                /*Encode raw */
	                BitStream_EncodeReal(pBitStrm, pVal->min.raw);
	                if (ret) {
	                    /*Encode acceleration */
	                    BitStream_EncodeReal(pBitStrm, pVal->min.acceleration);
	                }
	            }
	        }
	    }
	    if (ret) {
	        /*Encode max */
	        /*Encode position */
	        BitStream_EncodeReal(pBitStrm, pVal->max.position);
	        if (ret) {
	            /*Encode speed */
	            BitStream_EncodeReal(pBitStrm, pVal->max.speed);
	            if (ret) {
	                /*Encode effort */
	                BitStream_EncodeReal(pBitStrm, pVal->max.effort);
	                if (ret) {
	                    /*Encode raw */
	                    BitStream_EncodeReal(pBitStrm, pVal->max.raw);
	                    if (ret) {
	                        /*Encode acceleration */
	                        BitStream_EncodeReal(pBitStrm, pVal->max.acceleration);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointLimitRange_ACN_Decode(asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min */
	/*Decode position */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->min.position)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MIN_POSITION;
	if (ret) {
	    /*Decode speed */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->min.speed)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MIN_SPEED;
	    if (ret) {
	        /*Decode effort */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->min.effort)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MIN_EFFORT;
	        if (ret) {
	            /*Decode raw */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->min.raw)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MIN_RAW;
	            if (ret) {
	                /*Decode acceleration */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->min.acceleration)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MIN_ACCELERATION;
	            }
	        }
	    }
	}
	if (ret) {
	    /*Decode max */
	    /*Decode position */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->max.position)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MAX_POSITION;
	    if (ret) {
	        /*Decode speed */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->max.speed)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MAX_SPEED;
	        if (ret) {
	            /*Decode effort */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->max.effort)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MAX_EFFORT;
	            if (ret) {
	                /*Decode raw */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->max.raw)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MAX_RAW;
	                if (ret) {
	                    /*Decode acceleration */
	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->max.acceleration)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITRANGE_MAX_ACCELERATION;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Pressure_Initialize(asn1SccBase_Pressure* pVal)
{


	/*set pascal */
	asn1SccT_Float_Initialize((&(pVal->pascal)));
}

flag asn1SccBase_Pressure_IsConstraintValid(const asn1SccBase_Pressure *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_BASE_PRESSURE_PASCAL;

	return ret;
}

flag asn1SccBase_Pressure_Encode(const asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = asn1SccT_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccBase_Pressure_Decode(asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = asn1SccT_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);

	return ret  && asn1SccBase_Pressure_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Pressure_ACN_Encode(const asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    BitStream_EncodeReal(pBitStrm, pVal->pascal);
    }

	
    return ret;
}

flag asn1SccBase_Pressure_ACN_Decode(asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pascal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_PRESSURE_PASCAL;

    return ret && asn1SccBase_Pressure_IsConstraintValid(pVal, pErrCode);
}



void asn1SccGeometry_msgs_Point32_Initialize(asn1SccGeometry_msgs_Point32* pVal)
{


	/*set x */
	asn1SccT_Float_Initialize((&(pVal->x)));
	/*set y */
	asn1SccT_Float_Initialize((&(pVal->y)));
	/*set z */
	asn1SccT_Float_Initialize((&(pVal->z)));
}

flag asn1SccGeometry_msgs_Point32_IsConstraintValid(const asn1SccGeometry_msgs_Point32 *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->x) && (pVal->x <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT32_X;
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->y) && (pVal->y <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT32_Y;
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->z) && (pVal->z <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_GEOMETRY_MSGS_POINT32_Z;
        }
    }

	return ret;
}

flag asn1SccGeometry_msgs_Point32_Encode(const asn1SccGeometry_msgs_Point32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccGeometry_msgs_Point32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = asn1SccT_Float_Encode((&(pVal->x)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = asn1SccT_Float_Encode((&(pVal->y)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = asn1SccT_Float_Encode((&(pVal->z)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccGeometry_msgs_Point32_Decode(asn1SccGeometry_msgs_Point32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = asn1SccT_Float_Decode((&(pVal->x)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y */
	    ret = asn1SccT_Float_Decode((&(pVal->y)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z */
	        ret = asn1SccT_Float_Decode((&(pVal->z)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccGeometry_msgs_Point32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccGeometry_msgs_Point32_ACN_Encode(const asn1SccGeometry_msgs_Point32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccGeometry_msgs_Point32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    BitStream_EncodeReal(pBitStrm, pVal->x);
	    if (ret) {
	        /*Encode y */
	        BitStream_EncodeReal(pBitStrm, pVal->y);
	        if (ret) {
	            /*Encode z */
	            BitStream_EncodeReal(pBitStrm, pVal->z);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccGeometry_msgs_Point32_ACN_Decode(asn1SccGeometry_msgs_Point32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->x)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT32_X;
	if (ret) {
	    /*Decode y */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->y)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT32_Y;
	    if (ret) {
	        /*Decode z */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->z)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_GEOMETRY_MSGS_POINT32_Z;
	    }
	}

    return ret && asn1SccGeometry_msgs_Point32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_T_INT16;

	return ret;
}

flag asn1SccT_Int16_Encode(const asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    }

	
    return ret;
}

flag asn1SccT_Int16_Decode(asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;

	return ret  && asn1SccT_Int16_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int16_ACN_Encode(const asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    }

	
    return ret;
}

flag asn1SccT_Int16_ACN_Decode(asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT16;

    return ret && asn1SccT_Int16_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16;

	return ret;
}

flag asn1SccT_UInt16_Encode(const asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    }

	
    return ret;
}

flag asn1SccT_UInt16_Decode(asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt16_ACN_Encode(const asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    }

	
    return ret;
}

flag asn1SccT_UInt16_ACN_Decode(asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT16;

    return ret && asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_frame_size_t_Initialize(asn1SccBase_samples_frame_frame_size_t* pVal)
{


	/*set width */
	asn1SccT_UInt16_Initialize((&(pVal->width)));
	/*set height */
	asn1SccT_UInt16_Initialize((&(pVal->height)));
}

flag asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_size_t *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->width <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH;
    if (ret) {
        ret = (pVal->height <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT;
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_size_t_Encode(const asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode width */
	    ret = asn1SccT_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode height */
	        ret = asn1SccT_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_size_t_Decode(asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode width */
	ret = asn1SccT_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode height */
	    ret = asn1SccT_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_frame_size_t_ACN_Encode(const asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode width */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->width, 0, 65535);
	    if (ret) {
	        /*Encode height */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->height, 0, 65535);
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_size_t_ACN_Decode(asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode width */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->width)), 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH;
	if (ret) {
	    /*Decode height */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->height)), 0, 65535);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT;
	}

    return ret && asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_T_UINT64;

	return ret;
}

flag asn1SccT_UInt64_Encode(const asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    }

	
    return ret;
}

flag asn1SccT_UInt64_Decode(asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt64_ACN_Encode(const asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    }

	
    return ret;
}

flag asn1SccT_UInt64_ACN_Decode(asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT64;

    return ret && asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int64_Initialize(asn1SccT_Int64* pVal)
{

	(*(pVal)) = 0;
}

flag asn1SccT_Int64_IsConstraintValid(const asn1SccT_Int64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_T_INT64;

	return ret;
}

flag asn1SccT_Int64_Encode(const asn1SccT_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), LLONG_MIN, 9223372036854775807LL);
    }

	
    return ret;
}

flag asn1SccT_Int64_Decode(asn1SccT_Int64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT64;

	return ret  && asn1SccT_Int64_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int64_ACN_Encode(const asn1SccT_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccT_Int64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), LLONG_MIN, 9223372036854775807LL);
    }

	
    return ret;
}

flag asn1SccT_Int64_ACN_Decode(asn1SccT_Int64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT64;

    return ret && asn1SccT_Int64_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_Time_Initialize(asn1SccBase_Time* pVal)
{


	/*set microseconds */
	asn1SccT_Int64_Initialize((&(pVal->microseconds)));
}

flag asn1SccBase_Time_IsConstraintValid(const asn1SccBase_Time *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_TIME_MICROSECONDS;

	return ret;
}

flag asn1SccBase_Time_Encode(const asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = asn1SccT_Int64_Encode((&(pVal->microseconds)), pBitStrm, pErrCode, FALSE);
    }

	
    return ret;
}

flag asn1SccBase_Time_Decode(asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = asn1SccT_Int64_Decode((&(pVal->microseconds)), pBitStrm, pErrCode);

	return ret  && asn1SccBase_Time_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_Time_ACN_Encode(const asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->microseconds, LLONG_MIN, 9223372036854775807LL);
    }

	
    return ret;
}

flag asn1SccBase_Time_ACN_Decode(asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIME_MICROSECONDS;

    return ret && asn1SccBase_Time_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_TimeStamped_Base_commands_Motion2D_Initialize(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal)
{


	/*set translation */
	asn1SccT_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	asn1SccT_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	asn1SccBase_Angle_Initialize((&(pVal->heading)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const asn1SccBase_TimeStamped_Base_commands_Motion2D *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD;
            if (ret) {
                ret = TRUE;
                *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_MICROSECONDS;
            }
        }
    }

	return ret;
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_Encode(const asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_Decode(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_ACN_Encode(const asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    BitStream_EncodeReal(pBitStrm, pVal->translation);
	    if (ret) {
	        /*Encode rotation */
	        BitStream_EncodeReal(pBitStrm, pVal->rotation);
	        if (ret) {
	            /*Encode heading */
	            /*Encode rad */
	            BitStream_EncodeReal(pBitStrm, pVal->heading.rad);
	            if (ret) {
	                /*Encode time */
	                /*Encode microseconds */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_ACN_Decode(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->translation)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION;
	if (ret) {
	    /*Decode rotation */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rotation)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION;
	    if (ret) {
	        /*Decode heading */
	        /*Decode rad */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heading.rad)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD;
	        if (ret) {
	            /*Decode time */
	            /*Decode microseconds */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_MICROSECONDS;
	        }
	    }
	}

    return ret && asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_LinearAngular6DCommand_Initialize(asn1SccBase_LinearAngular6DCommand* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set linear */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->linear)));
	/*set angular */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular)));
}

flag asn1SccBase_LinearAngular6DCommand_IsConstraintValid(const asn1SccBase_LinearAngular6DCommand *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA;
        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA;
            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_LinearAngular6DCommand_Encode(const asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_LinearAngular6DCommand_Decode(asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_LinearAngular6DCommand_ACN_Encode(const asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode linear */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->linear.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->linear.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->linear.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode angular */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->angular.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->angular.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_LinearAngular6DCommand_ACN_Decode(asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_LINEARANGULAR6DCOMMAND_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode linear */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA;
	    pVal->linear.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->linear.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->linear.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode angular */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA;
	        pVal->angular.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->angular.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_BodyState_Initialize(asn1SccBase_samples_BodyState* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set pose */
	asn1SccBase_TransformWithCovariance_Initialize((&(pVal->pose)));
	/*set velocity */
	asn1SccBase_TwistWithCovariance_Initialize((&(pVal->velocity)));
}

flag asn1SccBase_samples_BodyState_IsConstraintValid(const asn1SccBase_samples_BodyState *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA;
        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM;
            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM;
            }

            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE;
            }
            if (ret) {
                ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA;
                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM;
                }

            }
        }
        if (ret) {
            ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA;
            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA;
                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA;
                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM;
                    }

                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_BodyState_Encode(const asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = asn1SccBase_TransformWithCovariance_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = asn1SccBase_TwistWithCovariance_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_BodyState_Decode(asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = asn1SccBase_TransformWithCovariance_Decode((&(pVal->pose)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = asn1SccBase_TwistWithCovariance_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_BodyState_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_BodyState_ACN_Encode(const asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode pose */
	        /*Encode translation */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.translation.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->pose.translation.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->pose.translation.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode orientation */
	            /*Encode im */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.orientation.im.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->pose.orientation.im.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->pose.orientation.im.arr[i1]);
	            }
	            if (ret) {
	                /*Encode re */
	                BitStream_EncodeReal(pBitStrm, pVal->pose.orientation.re);
	            }
	            if (ret) {
	                /*Encode cov */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.cov.data.nCount, 1, 36);
	                	
	                for(i1=0; (i1 < (int)pVal->pose.cov.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->pose.cov.data.arr[i1]);
	                }
	            }
	        }
	        if (ret) {
	            /*Encode velocity */
	            /*Encode vel */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.vel.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->velocity.vel.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->velocity.vel.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode rot */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.rot.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->velocity.rot.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->velocity.rot.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.cov.data.nCount, 1, 36);
	                    	
	                    for(i1=0; (i1 < (int)pVal->velocity.cov.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->velocity.cov.data.arr[i1]);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_BodyState_ACN_Decode(asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode pose */
	    /*Decode translation */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA;
	    pVal->pose.translation.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->pose.translation.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.translation.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode orientation */
	        /*Decode im */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM;
	        pVal->pose.orientation.im.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->pose.orientation.im.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.orientation.im.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM;
	        }
	        if (ret) {
	            /*Decode re */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.orientation.re)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE;
	        }
	        if (ret) {
	            /*Decode cov */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA;
	            pVal->pose.cov.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->pose.cov.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.cov.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM;
	            }
	        }
	    }
	    if (ret) {
	        /*Decode velocity */
	        /*Decode vel */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA;
	        pVal->velocity.vel.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->velocity.vel.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.vel.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode rot */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA;
	            pVal->velocity.rot.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->velocity.rot.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.rot.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA;
	                pVal->velocity.cov.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->velocity.cov.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.cov.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_BodyState_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_IMUSensors_Initialize(asn1SccBase_samples_IMUSensors* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set acc */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->acc)));
	/*set gyro */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->gyro)));
	/*set mag */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->mag)));
}

flag asn1SccBase_samples_IMUSensors_IsConstraintValid(const asn1SccBase_samples_IMUSensors *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA;
        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA;
            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA;
                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM;
                }

            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_IMUSensors_Encode(const asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_IMUSensors_Decode(asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_IMUSensors_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_IMUSensors_ACN_Encode(const asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode acc */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->acc.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->acc.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->acc.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode gyro */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->gyro.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->gyro.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->gyro.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode mag */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->mag.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->mag.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->mag.data.arr[i1]);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_IMUSensors_ACN_Decode(asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode acc */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_ACC_DATA;
	    pVal->acc.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->acc.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->acc.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode gyro */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_GYRO_DATA;
	        pVal->gyro.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->gyro.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->gyro.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode mag */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_MAG_DATA;
	            pVal->mag.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->mag.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->mag.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM;
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_IMUSensors_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Motion2D_Initialize(asn1SccBase_samples_Motion2D* pVal)
{


	/*set translation */
	asn1SccT_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	asn1SccT_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	asn1SccBase_Angle_Initialize((&(pVal->heading)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Motion2D_IsConstraintValid(const asn1SccBase_samples_Motion2D *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_TRANSLATION;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_ROTATION;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD;
            if (ret) {
                ret = TRUE;
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_TIME_MICROSECONDS;
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_Motion2D_Encode(const asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Motion2D_Decode(asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_Motion2D_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Motion2D_ACN_Encode(const asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    BitStream_EncodeReal(pBitStrm, pVal->translation);
	    if (ret) {
	        /*Encode rotation */
	        BitStream_EncodeReal(pBitStrm, pVal->rotation);
	        if (ret) {
	            /*Encode heading */
	            /*Encode rad */
	            BitStream_EncodeReal(pBitStrm, pVal->heading.rad);
	            if (ret) {
	                /*Encode time */
	                /*Encode microseconds */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Motion2D_ACN_Decode(asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->translation)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_MOTION2D_TRANSLATION;
	if (ret) {
	    /*Decode rotation */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rotation)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_MOTION2D_ROTATION;
	    if (ret) {
	        /*Decode heading */
	        /*Decode rad */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->heading.rad)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_MOTION2D_HEADING_RAD;
	        if (ret) {
	            /*Decode time */
	            /*Decode microseconds */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_MOTION2D_TIME_MICROSECONDS;
	        }
	    }
	}

    return ret && asn1SccBase_samples_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Pressure_Initialize(asn1SccBase_samples_Pressure* pVal)
{


	/*set pascal */
	asn1SccT_Float_Initialize((&(pVal->pascal)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Pressure_IsConstraintValid(const asn1SccBase_samples_Pressure *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_PRESSURE_PASCAL;
    if (ret) {
        ret = TRUE;
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_PRESSURE_TIME_MICROSECONDS;
    }

	return ret;
}

flag asn1SccBase_samples_Pressure_Encode(const asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = asn1SccT_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode time */
	        ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pressure_Decode(asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = asn1SccT_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode time */
	    ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_samples_Pressure_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Pressure_ACN_Encode(const asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    BitStream_EncodeReal(pBitStrm, pVal->pascal);
	    if (ret) {
	        /*Encode time */
	        /*Encode microseconds */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pressure_ACN_Decode(asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pascal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_PRESSURE_PASCAL;
	if (ret) {
	    /*Decode time */
	    /*Decode microseconds */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_PRESSURE_TIME_MICROSECONDS;
	}

    return ret && asn1SccBase_samples_Pressure_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_RigidBodyAcceleration_Initialize(asn1SccBase_samples_RigidBodyAcceleration* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set acceleration */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->acceleration)));
	/*set cov_acceleration */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
	/*set angular_acceleration */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
	/*set cov_angular_acceleration */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
}

flag asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA;
        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA;
            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA;
                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA;
                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM;
                    }

                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_Encode(const asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_Decode(asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_RigidBodyAcceleration_ACN_Encode(const asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode acceleration */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->acceleration.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->acceleration.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->acceleration.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode cov_acceleration */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_acceleration.data.nCount, 1, 9);
	            	
	            for(i1=0; (i1 < (int)pVal->cov_acceleration.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov_acceleration.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode angular_acceleration */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular_acceleration.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->angular_acceleration.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->angular_acceleration.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_angular_acceleration.data.nCount, 1, 9);
	                    	
	                    for(i1=0; (i1 < (int)pVal->cov_angular_acceleration.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->cov_angular_acceleration.data.arr[i1]);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_ACN_Decode(asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode acceleration */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA;
	    pVal->acceleration.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->acceleration.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->acceleration.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode cov_acceleration */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA;
	        pVal->cov_acceleration.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov_acceleration.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_acceleration.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode angular_acceleration */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA;
	            pVal->angular_acceleration.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->angular_acceleration.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_acceleration.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA;
	                pVal->cov_angular_acceleration.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->cov_angular_acceleration.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_angular_acceleration.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Wrench_Initialize(asn1SccBase_samples_Wrench* pVal)
{


	/*set force */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->torque)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Wrench_IsConstraintValid(const asn1SccBase_samples_Wrench *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA;
    for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA;
        for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM;
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TIME_MICROSECONDS;
        }
    }

	return ret;
}

flag asn1SccBase_samples_Wrench_Encode(const asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrench_Decode(asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_Wrench_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Wrench_ACN_Encode(const asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->force.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->force.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode torque */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->torque.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->torque.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrench_ACN_Decode(asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode force */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_FORCE_DATA;
	pVal->force.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->force.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM;
	}
	if (ret) {
	    /*Decode torque */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_TORQUE_DATA;
	    pVal->torque.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->torque.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_TIME_MICROSECONDS;
	    }
	}

    return ret && asn1SccBase_samples_Wrench_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_DepthMap_timestamps_Initialize(asn1SccBase_samples_DepthMap_timestamps* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DepthMap_vertical_interval_Initialize(asn1SccBase_samples_DepthMap_vertical_interval* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DepthMap_horizontal_interval_Initialize(asn1SccBase_samples_DepthMap_horizontal_interval* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DepthMap_distances_Initialize(asn1SccBase_samples_DepthMap_distances* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DepthMap_remissions_Initialize(asn1SccBase_samples_DepthMap_remissions* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DepthMap_Initialize(asn1SccBase_samples_DepthMap* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set timestamps */
	asn1SccBase_samples_DepthMap_timestamps_Initialize((&(pVal->timestamps)));
	/*set vertical_projection */
	asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->vertical_projection)));
	/*set horizontal_projection */
	asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->horizontal_projection)));
	/*set vertical_interval */
	asn1SccBase_samples_DepthMap_vertical_interval_Initialize((&(pVal->vertical_interval)));
	/*set horizontal_interval */
	asn1SccBase_samples_DepthMap_horizontal_interval_Initialize((&(pVal->horizontal_interval)));
	/*set vertical_size */
	asn1SccT_UInt32_Initialize((&(pVal->vertical_size)));
	/*set horizontal_size */
	asn1SccT_UInt32_Initialize((&(pVal->horizontal_size)));
	/*set distances */
	asn1SccBase_samples_DepthMap_distances_Initialize((&(pVal->distances)));
	/*set remissions */
	asn1SccBase_samples_DepthMap_remissions_Initialize((&(pVal->remissions)));
}

flag asn1SccBase_samples_DepthMap_IsConstraintValid(const asn1SccBase_samples_DepthMap *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
        for(i1 = 0; ret && i1 < pVal->timestamps.nCount; i1++) 
        {
        	ret = TRUE;
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_MICROSECONDS;
        }

        if (ret) {
            ret = (((pVal->vertical_projection == asn1Sccbase_samples_depthmap_projection_type_planar)) || ((pVal->vertical_projection == asn1Sccbase_samples_depthmap_projection_type_polar)));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;
            if (ret) {
                ret = (((pVal->horizontal_projection == asn1Sccbase_samples_depthmap_projection_type_planar)) || ((pVal->horizontal_projection == asn1Sccbase_samples_depthmap_projection_type_polar)));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;
                if (ret) {
                    ret = ((1 <= pVal->vertical_interval.nCount) && (pVal->vertical_interval.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
                    for(i1 = 0; ret && i1 < pVal->vertical_interval.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->vertical_interval.arr[i1]) && (pVal->vertical_interval.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM;
                    }

                    if (ret) {
                        ret = ((1 <= pVal->horizontal_interval.nCount) && (pVal->horizontal_interval.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
                        for(i1 = 0; ret && i1 < pVal->horizontal_interval.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->horizontal_interval.arr[i1]) && (pVal->horizontal_interval.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM;
                        }

                        if (ret) {
                            ret = (pVal->vertical_size <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE;
                            if (ret) {
                                ret = (pVal->horizontal_size <= 4294967295UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE;
                                if (ret) {
                                    ret = ((1 <= pVal->distances.nCount) && (pVal->distances.nCount <= 200));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES;
                                    for(i1 = 0; ret && i1 < pVal->distances.nCount; i1++) 
                                    {
                                    	ret = ((-3.40282346600000020000E+038 <= pVal->distances.arr[i1]) && (pVal->distances.arr[i1] <= 3.40282346600000020000E+038));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM;
                                    }

                                    if (ret) {
                                        ret = ((1 <= pVal->remissions.nCount) && (pVal->remissions.nCount <= 200));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
                                        for(i1 = 0; ret && i1 < pVal->remissions.nCount; i1++) 
                                        {
                                        	ret = ((-3.40282346600000020000E+038 <= pVal->remissions.arr[i1]) && (pVal->remissions.arr[i1] <= 3.40282346600000020000E+038));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM;
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_Encode(const asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode vertical_projection */
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->vertical_projection)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode horizontal_projection */
	                ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->horizontal_projection)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertical_interval.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccT_Double_Encode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horizontal_interval.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                        {
	                        	ret = asn1SccT_Double_Encode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode vertical_size */
	                            ret = asn1SccT_UInt32_Encode((&(pVal->vertical_size)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                ret = asn1SccT_UInt32_Encode((&(pVal->horizontal_size)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode distances */
	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->distances.nCount, 1, 200);
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccT_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remissions.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccT_Float_Encode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_Decode(asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode vertical_projection */
	        ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->vertical_projection)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode horizontal_projection */
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->horizontal_projection)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode vertical_interval */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
	                pVal->vertical_interval.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                {
	                	ret = asn1SccT_Double_Decode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode horizontal_interval */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
	                    pVal->horizontal_interval.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccT_Double_Decode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode vertical_size */
	                        ret = asn1SccT_UInt32_Decode((&(pVal->vertical_size)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode horizontal_size */
	                            ret = asn1SccT_UInt32_Decode((&(pVal->horizontal_size)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode distances */
	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES;
	                                pVal->distances.nCount = (long)nCount;
	                                	
	                                for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                {
	                                	ret = asn1SccT_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode remissions */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
	                                    pVal->remissions.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccT_Float_Decode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_DepthMap_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_DepthMap_ACN_Encode(const asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	/*Encode microseconds */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.arr[i1].microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	        if (ret) {
	            /*Encode vertical_projection */
	            switch(pVal->vertical_projection) { 
	                case asn1Sccbase_samples_depthmap_projection_type_planar:
	                    intVal = 0;
	                    break;
	                case asn1Sccbase_samples_depthmap_projection_type_polar:
	                    intVal = 1;
	                    break;
	                default:
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;                 /*COVERAGE_IGNORE*/
	            }
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
	            if (ret) {
	                /*Encode horizontal_projection */
	                switch(pVal->horizontal_projection) { 
	                    case asn1Sccbase_samples_depthmap_projection_type_planar:
	                        intVal = 0;
	                        break;
	                    case asn1Sccbase_samples_depthmap_projection_type_polar:
	                        intVal = 1;
	                        break;
	                    default:
	                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;                 /*COVERAGE_IGNORE*/
	                }
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertical_interval.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->vertical_interval.arr[i1]);
	                    }
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horizontal_interval.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->horizontal_interval.arr[i1]);
	                        }
	                        if (ret) {
	                            /*Encode vertical_size */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->vertical_size, 0, 4294967295LL);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->horizontal_size, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode distances */
	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->distances.nCount, 1, 200);
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                    {
	                                    	BitStream_EncodeReal(pBitStrm, pVal->distances.arr[i1]);
	                                    }
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remissions.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                        {
	                                        	BitStream_EncodeReal(pBitStrm, pVal->remissions.arr[i1]);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DepthMap_ACN_Decode(asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	asn1SccUint intVal;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	/*Decode microseconds */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->timestamps.arr[i1].microseconds)), LLONG_MIN, 9223372036854775807LL);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_MICROSECONDS;
	    }
	    if (ret) {
	        /*Decode vertical_projection */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 1);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;
	        if (ret) {
	            switch (intVal) {
	                case 0:
	                    pVal->vertical_projection = asn1Sccbase_samples_depthmap_projection_type_planar;
	                    break;
	                case 1:
	                    pVal->vertical_projection = asn1Sccbase_samples_depthmap_projection_type_polar;
	                    break;
	            default:
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;                 /*COVERAGE_IGNORE*/
	            }
	        }
	        if (ret) {
	            /*Decode horizontal_projection */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 1);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;
	            if (ret) {
	                switch (intVal) {
	                    case 0:
	                        pVal->horizontal_projection = asn1Sccbase_samples_depthmap_projection_type_planar;
	                        break;
	                    case 1:
	                        pVal->horizontal_projection = asn1Sccbase_samples_depthmap_projection_type_polar;
	                        break;
	                default:
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                    *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;                 /*COVERAGE_IGNORE*/
	                }
	            }
	            if (ret) {
	                /*Decode vertical_interval */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
	                pVal->vertical_interval.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->vertical_interval.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM;
	                }
	                if (ret) {
	                    /*Decode horizontal_interval */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
	                    pVal->horizontal_interval.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->horizontal_interval.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM;
	                    }
	                    if (ret) {
	                        /*Decode vertical_size */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->vertical_size)), 0, 4294967295LL);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE;
	                        if (ret) {
	                            /*Decode horizontal_size */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->horizontal_size)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE;
	                            if (ret) {
	                                /*Decode distances */
	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES;
	                                pVal->distances.nCount = (long)nCount;
	                                	
	                                for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                {
	                                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->distances.arr[i1])));
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM;
	                                }
	                                if (ret) {
	                                    /*Decode remissions */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
	                                    pVal->remissions.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                    {
	                                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->remissions.arr[i1])));
	                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_DepthMap_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_DistanceImage_data_Initialize(asn1SccBase_samples_DistanceImage_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_DistanceImage_Initialize(asn1SccBase_samples_DistanceImage* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set width */
	asn1SccT_UInt16_Initialize((&(pVal->width)));
	/*set height */
	asn1SccT_UInt16_Initialize((&(pVal->height)));
	/*set scale_x */
	asn1SccT_Float_Initialize((&(pVal->scale_x)));
	/*set scale_y */
	asn1SccT_Float_Initialize((&(pVal->scale_y)));
	/*set center_x */
	asn1SccT_Float_Initialize((&(pVal->center_x)));
	/*set center_y */
	asn1SccT_Float_Initialize((&(pVal->center_y)));
	/*set data */
	asn1SccBase_samples_DistanceImage_data_Initialize((&(pVal->data)));
}

flag asn1SccBase_samples_DistanceImage_IsConstraintValid(const asn1SccBase_samples_DistanceImage *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_TIME_MICROSECONDS;
    if (ret) {
        ret = (pVal->width <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH;
        if (ret) {
            ret = (pVal->height <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT;
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->scale_x) && (pVal->scale_x <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X;
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->scale_y) && (pVal->scale_y <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y;
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->center_x) && (pVal->center_x <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X;
                        if (ret) {
                            ret = ((-3.40282346600000020000E+038 <= pVal->center_y) && (pVal->center_y <= 3.40282346600000020000E+038));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y;
                            if (ret) {
                                ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA;
                                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
                                {
                                	ret = ((-3.40282346600000020000E+038 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 3.40282346600000020000E+038));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM;
                                }

                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_DistanceImage_Encode(const asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode width */
	        ret = asn1SccT_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode height */
	            ret = asn1SccT_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode scale_x */
	                ret = asn1SccT_Float_Encode((&(pVal->scale_x)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode scale_y */
	                    ret = asn1SccT_Float_Encode((&(pVal->scale_y)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode center_x */
	                        ret = asn1SccT_Float_Encode((&(pVal->center_x)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode center_y */
	                            ret = asn1SccT_Float_Encode((&(pVal->center_y)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                                {
	                                	ret = asn1SccT_Float_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DistanceImage_Decode(asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode width */
	    ret = asn1SccT_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode height */
	        ret = asn1SccT_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode scale_x */
	            ret = asn1SccT_Float_Decode((&(pVal->scale_x)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode scale_y */
	                ret = asn1SccT_Float_Decode((&(pVal->scale_y)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode center_x */
	                    ret = asn1SccT_Float_Decode((&(pVal->center_x)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode center_y */
	                        ret = asn1SccT_Float_Decode((&(pVal->center_y)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA;
	                            pVal->data.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                            {
	                            	ret = asn1SccT_Float_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_DistanceImage_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_DistanceImage_ACN_Encode(const asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode width */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->width, 0, 65535);
	        if (ret) {
	            /*Encode height */
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->height, 0, 65535);
	            if (ret) {
	                /*Encode scale_x */
	                BitStream_EncodeReal(pBitStrm, pVal->scale_x);
	                if (ret) {
	                    /*Encode scale_y */
	                    BitStream_EncodeReal(pBitStrm, pVal->scale_y);
	                    if (ret) {
	                        /*Encode center_x */
	                        BitStream_EncodeReal(pBitStrm, pVal->center_x);
	                        if (ret) {
	                            /*Encode center_y */
	                            BitStream_EncodeReal(pBitStrm, pVal->center_y);
	                            if (ret) {
	                                /*Encode data */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                                {
	                                	BitStream_EncodeReal(pBitStrm, pVal->data.arr[i1]);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_DistanceImage_ACN_Decode(asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode width */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->width)), 0, 65535);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_WIDTH;
	    if (ret) {
	        /*Decode height */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->height)), 0, 65535);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT;
	        if (ret) {
	            /*Decode scale_x */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->scale_x)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X;
	            if (ret) {
	                /*Decode scale_y */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->scale_y)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y;
	                if (ret) {
	                    /*Decode center_x */
	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->center_x)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X;
	                    if (ret) {
	                        /*Decode center_y */
	                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->center_y)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y;
	                        if (ret) {
	                            /*Decode data */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA;
	                            pVal->data.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                            {
	                            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->data.arr[i1])));
	                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_DistanceImage_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_LaserScan_ranges_Initialize(asn1SccBase_samples_LaserScan_ranges* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_UInt32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_LaserScan_remission_Initialize(asn1SccBase_samples_LaserScan_remission* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_LaserScan_Initialize(asn1SccBase_samples_LaserScan* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set start_angle */
	asn1SccT_Double_Initialize((&(pVal->start_angle)));
	/*set angular_resolution */
	asn1SccT_Double_Initialize((&(pVal->angular_resolution)));
	/*set speed */
	asn1SccT_Double_Initialize((&(pVal->speed)));
	/*set ranges */
	asn1SccBase_samples_LaserScan_ranges_Initialize((&(pVal->ranges)));
	/*set minrange */
	asn1SccT_UInt32_Initialize((&(pVal->minrange)));
	/*set maxrange */
	asn1SccT_UInt32_Initialize((&(pVal->maxrange)));
	/*set remission */
	asn1SccBase_samples_LaserScan_remission_Initialize((&(pVal->remission)));
}

flag asn1SccBase_samples_LaserScan_IsConstraintValid(const asn1SccBase_samples_LaserScan *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_TIME_MICROSECONDS;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->start_angle) && (pVal->start_angle <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution) && (pVal->angular_resolution <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION;
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_SPEED;
                if (ret) {
                    ret = ((1 <= pVal->ranges.nCount) && (pVal->ranges.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES;
                    for(i1 = 0; ret && i1 < pVal->ranges.nCount; i1++) 
                    {
                    	ret = (pVal->ranges.arr[i1] <= 4294967295UL);
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM;
                    }

                    if (ret) {
                        ret = (pVal->minrange <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MINRANGE;
                        if (ret) {
                            ret = (pVal->maxrange <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE;
                            if (ret) {
                                ret = ((1 <= pVal->remission.nCount) && (pVal->remission.nCount <= 200));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION;
                                for(i1 = 0; ret && i1 < pVal->remission.nCount; i1++) 
                                {
                                	ret = ((-3.40282346600000020000E+038 <= pVal->remission.arr[i1]) && (pVal->remission.arr[i1] <= 3.40282346600000020000E+038));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM;
                                }

                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_LaserScan_Encode(const asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode start_angle */
	        ret = asn1SccT_Double_Encode((&(pVal->start_angle)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular_resolution */
	            ret = asn1SccT_Double_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed */
	                ret = asn1SccT_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode ranges */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->ranges.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccT_UInt32_Encode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode minrange */
	                        ret = asn1SccT_UInt32_Encode((&(pVal->minrange)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode maxrange */
	                            ret = asn1SccT_UInt32_Encode((&(pVal->maxrange)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode remission */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remission.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                                {
	                                	ret = asn1SccT_Float_Encode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_LaserScan_Decode(asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode start_angle */
	    ret = asn1SccT_Double_Decode((&(pVal->start_angle)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular_resolution */
	        ret = asn1SccT_Double_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed */
	            ret = asn1SccT_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode ranges */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES;
	                pVal->ranges.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                {
	                	ret = asn1SccT_UInt32_Decode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode minrange */
	                    ret = asn1SccT_UInt32_Decode((&(pVal->minrange)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode maxrange */
	                        ret = asn1SccT_UInt32_Decode((&(pVal->maxrange)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode remission */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION;
	                            pVal->remission.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                            {
	                            	ret = asn1SccT_Float_Decode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_LaserScan_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_LaserScan_ACN_Encode(const asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode start_angle */
	        BitStream_EncodeReal(pBitStrm, pVal->start_angle);
	        if (ret) {
	            /*Encode angular_resolution */
	            BitStream_EncodeReal(pBitStrm, pVal->angular_resolution);
	            if (ret) {
	                /*Encode speed */
	                BitStream_EncodeReal(pBitStrm, pVal->speed);
	                if (ret) {
	                    /*Encode ranges */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->ranges.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->ranges.arr[i1], 0, 4294967295LL);
	                    }
	                    if (ret) {
	                        /*Encode minrange */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->minrange, 0, 4294967295LL);
	                        if (ret) {
	                            /*Encode maxrange */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->maxrange, 0, 4294967295LL);
	                            if (ret) {
	                                /*Encode remission */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remission.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                                {
	                                	BitStream_EncodeReal(pBitStrm, pVal->remission.arr[i1]);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_LaserScan_ACN_Decode(asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode start_angle */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->start_angle)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_START_ANGLE;
	    if (ret) {
	        /*Decode angular_resolution */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_resolution)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION;
	        if (ret) {
	            /*Decode speed */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_SPEED;
	            if (ret) {
	                /*Decode ranges */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_RANGES;
	                pVal->ranges.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->ranges.arr[i1])), 0, 4294967295LL);
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_RANGES_ELM;
	                }
	                if (ret) {
	                    /*Decode minrange */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->minrange)), 0, 4294967295LL);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_MINRANGE;
	                    if (ret) {
	                        /*Decode maxrange */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->maxrange)), 0, 4294967295LL);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_MAXRANGE;
	                        if (ret) {
	                            /*Decode remission */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION;
	                            pVal->remission.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                            {
	                            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->remission.arr[i1])));
	                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION_ELM;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_LaserScan_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Pointcloud_points_Initialize(asn1SccBase_samples_Pointcloud_points* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccWrappers_Vector3d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Pointcloud_colors_Initialize(asn1SccBase_samples_Pointcloud_colors* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccWrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Pointcloud_Initialize(asn1SccBase_samples_Pointcloud* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set points */
	asn1SccBase_samples_Pointcloud_points_Initialize((&(pVal->points)));
	/*set colors */
	asn1SccBase_samples_Pointcloud_colors_Initialize((&(pVal->colors)));
}

flag asn1SccBase_samples_Pointcloud_IsConstraintValid(const asn1SccBase_samples_Pointcloud *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS;
        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++) 
        {
        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA;
        	for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM;
        	}

        }

        if (ret) {
            ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS;
            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++) 
            {
            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA;
            	for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++) 
            	{
            		ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
            		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM;
            	}

            }

        }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_Encode(const asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccWrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccWrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pointcloud_Decode(asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccWrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_Pointcloud_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Pointcloud_ACN_Encode(const asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.arr[i1].data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->points.arr[i1].data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->points.arr[i1].data.arr[i2]);
	        	}
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	/*Encode data */
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.arr[i1].data.nCount, 1, 4);
	            		
	            	for(i2=0; (i2 < (int)pVal->colors.arr[i1].data.nCount) && ret; i2++) 
	            	{
	            		BitStream_EncodeReal(pBitStrm, pVal->colors.arr[i1].data.arr[i2]);
	            	}
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pointcloud_ACN_Decode(asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA;
	    	pVal->points.arr[i1].data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->points.arr[i1].data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->points.arr[i1].data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM;
	    	}
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	/*Decode data */
	        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA;
	        	pVal->colors.arr[i1].data.nCount = (long)nCount;
	        		
	        	for(i2=0; (i2 < (int)pVal->colors.arr[i1].data.nCount) && ret; i2++) 
	        	{
	        		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->colors.arr[i1].data.arr[i2])));
	        		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM;
	        	}
	        }
	    }
	}

    return ret && asn1SccBase_samples_Pointcloud_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Sonar_timestamps_Initialize(asn1SccBase_samples_Sonar_timestamps* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Sonar_bearings_Initialize(asn1SccBase_samples_Sonar_bearings* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Angle_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Sonar_bins_Initialize(asn1SccBase_samples_Sonar_bins* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Sonar_Initialize(asn1SccBase_samples_Sonar* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set timestamps */
	asn1SccBase_samples_Sonar_timestamps_Initialize((&(pVal->timestamps)));
	/*set bin_duration */
	asn1SccBase_Time_Initialize((&(pVal->bin_duration)));
	/*set beam_width */
	asn1SccBase_Angle_Initialize((&(pVal->beam_width)));
	/*set beam_height */
	asn1SccBase_Angle_Initialize((&(pVal->beam_height)));
	/*set bearings */
	asn1SccBase_samples_Sonar_bearings_Initialize((&(pVal->bearings)));
	/*set speed_of_sound */
	asn1SccT_Float_Initialize((&(pVal->speed_of_sound)));
	/*set bin_count */
	asn1SccT_UInt32_Initialize((&(pVal->bin_count)));
	/*set beam_count */
	asn1SccT_UInt32_Initialize((&(pVal->beam_count)));
	/*set bins */
	asn1SccBase_samples_Sonar_bins_Initialize((&(pVal->bins)));
}

flag asn1SccBase_samples_Sonar_IsConstraintValid(const asn1SccBase_samples_Sonar *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_TIMESTAMPS;
        for(i1 = 0; ret && i1 < pVal->timestamps.nCount; i1++) 
        {
        	ret = TRUE;
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_MICROSECONDS;
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BIN_DURATION_MICROSECONDS;
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->beam_width.rad) && (pVal->beam_width.rad <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD;
                if (ret) {
                    ret = ((-1.79769313486231570000E+308 <= pVal->beam_height.rad) && (pVal->beam_height.rad <= 1.79769313486231570000E+308));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD;
                    if (ret) {
                        ret = ((1 <= pVal->bearings.nCount) && (pVal->bearings.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS;
                        for(i1 = 0; ret && i1 < pVal->bearings.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->bearings.arr[i1].rad) && (pVal->bearings.arr[i1].rad <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD;
                        }

                        if (ret) {
                            ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND;
                            if (ret) {
                                ret = (pVal->bin_count <= 4294967295UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BIN_COUNT;
                                if (ret) {
                                    ret = (pVal->beam_count <= 4294967295UL);
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_COUNT;
                                    if (ret) {
                                        ret = ((1 <= pVal->bins.nCount) && (pVal->bins.nCount <= 200));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS;
                                        for(i1 = 0; ret && i1 < pVal->bins.nCount; i1++) 
                                        {
                                        	ret = ((-3.40282346600000020000E+038 <= pVal->bins.arr[i1]) && (pVal->bins.arr[i1] <= 3.40282346600000020000E+038));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS_ELM;
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_Sonar_Encode(const asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode bin_duration */
	            ret = asn1SccBase_Time_Encode((&(pVal->bin_duration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode beam_width */
	                ret = asn1SccBase_Angle_Encode((&(pVal->beam_width)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beam_height */
	                    ret = asn1SccBase_Angle_Encode((&(pVal->beam_height)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode bearings */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bearings.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                        {
	                        	ret = asn1SccBase_Angle_Encode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode speed_of_sound */
	                            ret = asn1SccT_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode bin_count */
	                                ret = asn1SccT_UInt32_Encode((&(pVal->bin_count)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode beam_count */
	                                    ret = asn1SccT_UInt32_Encode((&(pVal->beam_count)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode bins */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bins.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccT_Float_Encode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Sonar_Decode(asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode bin_duration */
	        ret = asn1SccBase_Time_Decode((&(pVal->bin_duration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode beam_width */
	            ret = asn1SccBase_Angle_Decode((&(pVal->beam_width)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beam_height */
	                ret = asn1SccBase_Angle_Decode((&(pVal->beam_height)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode bearings */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS;
	                    pVal->bearings.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                    {
	                    	ret = asn1SccBase_Angle_Decode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode speed_of_sound */
	                        ret = asn1SccT_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode bin_count */
	                            ret = asn1SccT_UInt32_Decode((&(pVal->bin_count)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode beam_count */
	                                ret = asn1SccT_UInt32_Decode((&(pVal->beam_count)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode bins */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS;
	                                    pVal->bins.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccT_Float_Decode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_Sonar_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Sonar_ACN_Encode(const asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	/*Encode microseconds */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.arr[i1].microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	        if (ret) {
	            /*Encode bin_duration */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bin_duration.microseconds, LLONG_MIN, 9223372036854775807LL);
	            if (ret) {
	                /*Encode beam_width */
	                /*Encode rad */
	                BitStream_EncodeReal(pBitStrm, pVal->beam_width.rad);
	                if (ret) {
	                    /*Encode beam_height */
	                    /*Encode rad */
	                    BitStream_EncodeReal(pBitStrm, pVal->beam_height.rad);
	                    if (ret) {
	                        /*Encode bearings */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bearings.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                        {
	                        	/*Encode rad */
	                        	BitStream_EncodeReal(pBitStrm, pVal->bearings.arr[i1].rad);
	                        }
	                        if (ret) {
	                            /*Encode speed_of_sound */
	                            BitStream_EncodeReal(pBitStrm, pVal->speed_of_sound);
	                            if (ret) {
	                                /*Encode bin_count */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->bin_count, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode beam_count */
	                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->beam_count, 0, 4294967295LL);
	                                    if (ret) {
	                                        /*Encode bins */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bins.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                        {
	                                        	BitStream_EncodeReal(pBitStrm, pVal->bins.arr[i1]);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Sonar_ACN_Decode(asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	/*Decode microseconds */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->timestamps.arr[i1].microseconds)), LLONG_MIN, 9223372036854775807LL);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_MICROSECONDS;
	    }
	    if (ret) {
	        /*Decode bin_duration */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->bin_duration.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BIN_DURATION_MICROSECONDS;
	        if (ret) {
	            /*Decode beam_width */
	            /*Decode rad */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beam_width.rad)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD;
	            if (ret) {
	                /*Decode beam_height */
	                /*Decode rad */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beam_height.rad)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD;
	                if (ret) {
	                    /*Decode bearings */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BEARINGS;
	                    pVal->bearings.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                    {
	                    	/*Decode rad */
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->bearings.arr[i1].rad)));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD;
	                    }
	                    if (ret) {
	                        /*Decode speed_of_sound */
	                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed_of_sound)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_SPEED_OF_SOUND;
	                        if (ret) {
	                            /*Decode bin_count */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->bin_count)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BIN_COUNT;
	                            if (ret) {
	                                /*Decode beam_count */
	                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->beam_count)), 0, 4294967295LL);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BEAM_COUNT;
	                                if (ret) {
	                                    /*Decode bins */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BINS;
	                                    pVal->bins.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                    {
	                                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->bins.arr[i1])));
	                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONAR_BINS_ELM;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_Sonar_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_SonarBeam_beam_Initialize(asn1SccBase_samples_SonarBeam_beam* pVal)
{

	memset(pVal->arr, 0x0, 200);

}
void asn1SccBase_samples_SonarBeam_Initialize(asn1SccBase_samples_SonarBeam* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set bearing */
	asn1SccBase_Angle_Initialize((&(pVal->bearing)));
	/*set sampling_interval */
	asn1SccT_Double_Initialize((&(pVal->sampling_interval)));
	/*set speed_of_sound */
	asn1SccT_Float_Initialize((&(pVal->speed_of_sound)));
	/*set beamwidth_horizontal */
	asn1SccT_Float_Initialize((&(pVal->beamwidth_horizontal)));
	/*set beamwidth_vertical */
	asn1SccT_Float_Initialize((&(pVal->beamwidth_vertical)));
	/*set beam */
	asn1SccBase_samples_SonarBeam_beam_Initialize((&(pVal->beam)));
}

flag asn1SccBase_samples_SonarBeam_IsConstraintValid(const asn1SccBase_samples_SonarBeam *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_TIME_MICROSECONDS;
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->bearing.rad) && (pVal->bearing.rad <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD;
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL;
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND;
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_horizontal) && (pVal->beamwidth_horizontal <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL;
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_vertical) && (pVal->beamwidth_vertical <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL;
                        if (ret) {
                            ret = ((1 <= pVal->beam.nCount) && (pVal->beam.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAM;
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_SonarBeam_Encode(const asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode bearing */
	        ret = asn1SccBase_Angle_Encode((&(pVal->bearing)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode sampling_interval */
	            ret = asn1SccT_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed_of_sound */
	                ret = asn1SccT_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beamwidth_horizontal */
	                    ret = asn1SccT_Float_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode beamwidth_vertical */
	                        ret = asn1SccT_Float_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode beam */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->beam.nCount, 1, 200);
	                            	
	                            for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                            {
	                            	BitStream_AppendByte0(pBitStrm, pVal->beam.arr[i1]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_SonarBeam_Decode(asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode bearing */
	    ret = asn1SccBase_Angle_Decode((&(pVal->bearing)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode sampling_interval */
	        ret = asn1SccT_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed_of_sound */
	            ret = asn1SccT_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beamwidth_horizontal */
	                ret = asn1SccT_Float_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode beamwidth_vertical */
	                    ret = asn1SccT_Float_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode beam */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        pVal->beam.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_ReadByte(pBitStrm, &(pVal->beam.arr[i1])); 
	                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_SonarBeam_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_SonarBeam_ACN_Encode(const asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode bearing */
	        /*Encode rad */
	        BitStream_EncodeReal(pBitStrm, pVal->bearing.rad);
	        if (ret) {
	            /*Encode sampling_interval */
	            BitStream_EncodeReal(pBitStrm, pVal->sampling_interval);
	            if (ret) {
	                /*Encode speed_of_sound */
	                BitStream_EncodeReal(pBitStrm, pVal->speed_of_sound);
	                if (ret) {
	                    /*Encode beamwidth_horizontal */
	                    BitStream_EncodeReal(pBitStrm, pVal->beamwidth_horizontal);
	                    if (ret) {
	                        /*Encode beamwidth_vertical */
	                        BitStream_EncodeReal(pBitStrm, pVal->beamwidth_vertical);
	                        if (ret) {
	                            /*Encode beam */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->beam.nCount, 1, 200);
	                            	
	                            for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                            {
	                            	BitStream_AppendByte0(pBitStrm, pVal->beam.arr[i1]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_SonarBeam_ACN_Decode(asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode bearing */
	    /*Decode rad */
	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->bearing.rad)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_BEARING_RAD;
	    if (ret) {
	        /*Decode sampling_interval */
	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->sampling_interval)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL;
	        if (ret) {
	            /*Decode speed_of_sound */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed_of_sound)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND;
	            if (ret) {
	                /*Decode beamwidth_horizontal */
	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beamwidth_horizontal)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL;
	                if (ret) {
	                    /*Decode beamwidth_vertical */
	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beamwidth_vertical)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL;
	                    if (ret) {
	                        /*Decode beam */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        pVal->beam.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_ReadByte(pBitStrm, &(pVal->beam.arr[i1])); 
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_SonarBeam_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_SonarScan_data_Initialize(asn1SccBase_samples_SonarScan_data* pVal)
{

	memset(pVal->arr, 0x0, 200);

}
void asn1SccBase_samples_SonarScan_time_beams_Initialize(asn1SccBase_samples_SonarScan_time_beams* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_SonarScan_Initialize(asn1SccBase_samples_SonarScan* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set data */
	asn1SccBase_samples_SonarScan_data_Initialize((&(pVal->data)));
	/*set time_beams */
	asn1SccBase_samples_SonarScan_time_beams_Initialize((&(pVal->time_beams)));
	/*set number_of_beams */
	asn1SccT_UInt16_Initialize((&(pVal->number_of_beams)));
	/*set number_of_bins */
	asn1SccT_UInt16_Initialize((&(pVal->number_of_bins)));
	/*set start_bearing */
	asn1SccBase_Angle_Initialize((&(pVal->start_bearing)));
	/*set angular_resolution */
	asn1SccBase_Angle_Initialize((&(pVal->angular_resolution)));
	/*set sampling_interval */
	asn1SccT_Double_Initialize((&(pVal->sampling_interval)));
	/*set speed_of_sound */
	asn1SccT_Float_Initialize((&(pVal->speed_of_sound)));
	/*set beamwidth_horizontal */
	asn1SccBase_Angle_Initialize((&(pVal->beamwidth_horizontal)));
	/*set beamwidth_vertical */
	asn1SccBase_Angle_Initialize((&(pVal->beamwidth_vertical)));
	/*set memory_layout_column */
	asn1SccT_Boolean_Initialize((&(pVal->memory_layout_column)));
	/*set polar_coordinates */
	asn1SccT_Boolean_Initialize((&(pVal->polar_coordinates)));
}

flag asn1SccBase_samples_SonarScan_IsConstraintValid(const asn1SccBase_samples_SonarScan *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_DATA;
        if (ret) {
            ret = ((1 <= pVal->time_beams.nCount) && (pVal->time_beams.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
            for(i1 = 0; ret && i1 < pVal->time_beams.nCount; i1++) 
            {
            	ret = TRUE;
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_MICROSECONDS;
            }

            if (ret) {
                ret = (pVal->number_of_beams <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS;
                if (ret) {
                    ret = (pVal->number_of_bins <= 65535UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS;
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->start_bearing.rad) && (pVal->start_bearing.rad <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD;
                        if (ret) {
                            ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution.rad) && (pVal->angular_resolution.rad <= 1.79769313486231570000E+308));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD;
                            if (ret) {
                                ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL;
                                if (ret) {
                                    ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND;
                                    if (ret) {
                                        ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_horizontal.rad) && (pVal->beamwidth_horizontal.rad <= 1.79769313486231570000E+308));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD;
                                        if (ret) {
                                            ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_vertical.rad) && (pVal->beamwidth_vertical.rad <= 1.79769313486231570000E+308));
                                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD;
                                            if (ret) {
                                                ret = TRUE;
                                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN;
                                                if (ret) {
                                                    ret = TRUE;
                                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_SonarScan_Encode(const asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode time_beams */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccBase_Time_Encode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode number_of_beams */
	                ret = asn1SccT_UInt16_Encode((&(pVal->number_of_beams)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode number_of_bins */
	                    ret = asn1SccT_UInt16_Encode((&(pVal->number_of_bins)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode start_bearing */
	                        ret = asn1SccBase_Angle_Encode((&(pVal->start_bearing)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode angular_resolution */
	                            ret = asn1SccBase_Angle_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode sampling_interval */
	                                ret = asn1SccT_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode speed_of_sound */
	                                    ret = asn1SccT_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode beamwidth_horizontal */
	                                        ret = asn1SccBase_Angle_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode beamwidth_vertical */
	                                            ret = asn1SccBase_Angle_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode memory_layout_column */
	                                                ret = asn1SccT_Boolean_Encode((&(pVal->memory_layout_column)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode polar_coordinates */
	                                                    ret = asn1SccT_Boolean_Encode((&(pVal->polar_coordinates)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_SonarScan_Decode(asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    pVal->data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    }
	    if (ret) {
	        /*Decode time_beams */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
	        pVal->time_beams.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Time_Decode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode number_of_beams */
	            ret = asn1SccT_UInt16_Decode((&(pVal->number_of_beams)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode number_of_bins */
	                ret = asn1SccT_UInt16_Decode((&(pVal->number_of_bins)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode start_bearing */
	                    ret = asn1SccBase_Angle_Decode((&(pVal->start_bearing)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode angular_resolution */
	                        ret = asn1SccBase_Angle_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode sampling_interval */
	                            ret = asn1SccT_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode speed_of_sound */
	                                ret = asn1SccT_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode beamwidth_horizontal */
	                                    ret = asn1SccBase_Angle_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode beamwidth_vertical */
	                                        ret = asn1SccBase_Angle_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode memory_layout_column */
	                                            ret = asn1SccT_Boolean_Decode((&(pVal->memory_layout_column)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode polar_coordinates */
	                                                ret = asn1SccT_Boolean_Decode((&(pVal->polar_coordinates)), pBitStrm, pErrCode);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_SonarScan_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_SonarScan_ACN_Encode(const asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode time_beams */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	            {
	            	/*Encode microseconds */
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.arr[i1].microseconds, LLONG_MIN, 9223372036854775807LL);
	            }
	            if (ret) {
	                /*Encode number_of_beams */
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->number_of_beams, 0, 65535);
	                if (ret) {
	                    /*Encode number_of_bins */
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->number_of_bins, 0, 65535);
	                    if (ret) {
	                        /*Encode start_bearing */
	                        /*Encode rad */
	                        BitStream_EncodeReal(pBitStrm, pVal->start_bearing.rad);
	                        if (ret) {
	                            /*Encode angular_resolution */
	                            /*Encode rad */
	                            BitStream_EncodeReal(pBitStrm, pVal->angular_resolution.rad);
	                            if (ret) {
	                                /*Encode sampling_interval */
	                                BitStream_EncodeReal(pBitStrm, pVal->sampling_interval);
	                                if (ret) {
	                                    /*Encode speed_of_sound */
	                                    BitStream_EncodeReal(pBitStrm, pVal->speed_of_sound);
	                                    if (ret) {
	                                        /*Encode beamwidth_horizontal */
	                                        /*Encode rad */
	                                        BitStream_EncodeReal(pBitStrm, pVal->beamwidth_horizontal.rad);
	                                        if (ret) {
	                                            /*Encode beamwidth_vertical */
	                                            /*Encode rad */
	                                            BitStream_EncodeReal(pBitStrm, pVal->beamwidth_vertical.rad);
	                                            if (ret) {
	                                                /*Encode memory_layout_column */
	                                                BitStream_AppendBit(pBitStrm,pVal->memory_layout_column);
	                                                if (ret) {
	                                                    /*Encode polar_coordinates */
	                                                    BitStream_AppendBit(pBitStrm,pVal->polar_coordinates);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_SonarScan_ACN_Decode(asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    pVal->data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    }
	    if (ret) {
	        /*Decode time_beams */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
	        pVal->time_beams.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	        {
	        	/*Decode microseconds */
	        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time_beams.arr[i1].microseconds)), LLONG_MIN, 9223372036854775807LL);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_MICROSECONDS;
	        }
	        if (ret) {
	            /*Decode number_of_beams */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->number_of_beams)), 0, 65535);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS;
	            if (ret) {
	                /*Decode number_of_bins */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->number_of_bins)), 0, 65535);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS;
	                if (ret) {
	                    /*Decode start_bearing */
	                    /*Decode rad */
	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->start_bearing.rad)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD;
	                    if (ret) {
	                        /*Decode angular_resolution */
	                        /*Decode rad */
	                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_resolution.rad)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD;
	                        if (ret) {
	                            /*Decode sampling_interval */
	                            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->sampling_interval)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL;
	                            if (ret) {
	                                /*Decode speed_of_sound */
	                                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->speed_of_sound)));
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND;
	                                if (ret) {
	                                    /*Decode beamwidth_horizontal */
	                                    /*Decode rad */
	                                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beamwidth_horizontal.rad)));
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD;
	                                    if (ret) {
	                                        /*Decode beamwidth_vertical */
	                                        /*Decode rad */
	                                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->beamwidth_vertical.rad)));
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD;
	                                        if (ret) {
	                                            /*Decode memory_layout_column */
	                                            ret = BitStream_ReadBit(pBitStrm, (&(pVal->memory_layout_column)));
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN;
	                                            if (ret) {
	                                                /*Decode polar_coordinates */
	                                                ret = BitStream_ReadBit(pBitStrm, (&(pVal->polar_coordinates)));
	                                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES;
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_SonarScan_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_commands_LinearAngular6DCommand_m_Initialize(asn1SccBase_commands_LinearAngular6DCommand_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set linear */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->linear)));
	/*set angular */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular)));
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(const asn1SccBase_commands_LinearAngular6DCommand_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA;
        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA;
            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_Encode(const asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_Decode(asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_ACN_Encode(const asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode linear */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->linear.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->linear.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->linear.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode angular */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->angular.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->angular.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_ACN_Decode(asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode linear */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA;
	    pVal->linear.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->linear.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->linear.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode angular */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA;
	        pVal->angular.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->angular.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_BodyState_m_Initialize(asn1SccBase_samples_BodyState_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set pose */
	asn1SccBase_TransformWithCovariance_m_Initialize((&(pVal->pose)));
	/*set velocity */
	asn1SccBase_TwistWithCovariance_m_Initialize((&(pVal->velocity)));
}

flag asn1SccBase_samples_BodyState_m_IsConstraintValid(const asn1SccBase_samples_BodyState_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA;
        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM;
            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM;
            }

            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE;
            }
            if (ret) {
                ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA;
                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM;
                }

            }
        }
        if (ret) {
            ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA;
            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA;
                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA;
                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM;
                    }

                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_BodyState_m_Encode(const asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = asn1SccBase_TransformWithCovariance_m_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = asn1SccBase_TwistWithCovariance_m_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_BodyState_m_Decode(asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = asn1SccBase_TransformWithCovariance_m_Decode((&(pVal->pose)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = asn1SccBase_TwistWithCovariance_m_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_BodyState_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_BodyState_m_ACN_Encode(const asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode pose */
	        /*Encode translation */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.translation.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->pose.translation.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->pose.translation.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode orientation */
	            /*Encode im */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.orientation.im.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->pose.orientation.im.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->pose.orientation.im.arr[i1]);
	            }
	            if (ret) {
	                /*Encode re */
	                BitStream_EncodeReal(pBitStrm, pVal->pose.orientation.re);
	            }
	            if (ret) {
	                /*Encode cov */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->pose.cov.data.nCount, 1, 36);
	                	
	                for(i1=0; (i1 < (int)pVal->pose.cov.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->pose.cov.data.arr[i1]);
	                }
	            }
	        }
	        if (ret) {
	            /*Encode velocity */
	            /*Encode vel */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.vel.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->velocity.vel.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->velocity.vel.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode rot */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.rot.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->velocity.rot.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->velocity.rot.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.cov.data.nCount, 1, 36);
	                    	
	                    for(i1=0; (i1 < (int)pVal->velocity.cov.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->velocity.cov.data.arr[i1]);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_BodyState_m_ACN_Decode(asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode pose */
	    /*Decode translation */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA;
	    pVal->pose.translation.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->pose.translation.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.translation.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode orientation */
	        /*Decode im */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM;
	        pVal->pose.orientation.im.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->pose.orientation.im.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.orientation.im.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM;
	        }
	        if (ret) {
	            /*Decode re */
	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.orientation.re)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE;
	        }
	        if (ret) {
	            /*Decode cov */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA;
	            pVal->pose.cov.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->pose.cov.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->pose.cov.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM;
	            }
	        }
	    }
	    if (ret) {
	        /*Decode velocity */
	        /*Decode vel */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA;
	        pVal->velocity.vel.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->velocity.vel.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.vel.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode rot */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA;
	            pVal->velocity.rot.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->velocity.rot.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.rot.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA;
	                pVal->velocity.cov.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->velocity.cov.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.cov.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_BodyState_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_IMUSensors_m_Initialize(asn1SccBase_samples_IMUSensors_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set acc */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->acc)));
	/*set gyro */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->gyro)));
	/*set mag */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->mag)));
}

flag asn1SccBase_samples_IMUSensors_m_IsConstraintValid(const asn1SccBase_samples_IMUSensors_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA;
        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA;
            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA;
                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM;
                }

            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_IMUSensors_m_Encode(const asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_IMUSensors_m_Decode(asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_IMUSensors_m_ACN_Encode(const asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode acc */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->acc.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->acc.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->acc.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode gyro */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->gyro.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->gyro.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->gyro.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode mag */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->mag.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->mag.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->mag.data.arr[i1]);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_IMUSensors_m_ACN_Decode(asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode acc */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA;
	    pVal->acc.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->acc.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->acc.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode gyro */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA;
	        pVal->gyro.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->gyro.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->gyro.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode mag */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA;
	            pVal->mag.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->mag.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->mag.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM;
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_RigidBodyAcceleration_m_Initialize(asn1SccBase_samples_RigidBodyAcceleration_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set acceleration */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->acceleration)));
	/*set cov_acceleration */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
	/*set angular_acceleration */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
	/*set cov_angular_acceleration */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA;
        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM;
        }

        if (ret) {
            ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA;
            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM;
            }

            if (ret) {
                ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA;
                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA;
                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM;
                    }

                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_Encode(const asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_Decode(asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_ACN_Encode(const asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode acceleration */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->acceleration.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->acceleration.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->acceleration.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode cov_acceleration */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_acceleration.data.nCount, 1, 9);
	            	
	            for(i1=0; (i1 < (int)pVal->cov_acceleration.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->cov_acceleration.data.arr[i1]);
	            }
	            if (ret) {
	                /*Encode angular_acceleration */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular_acceleration.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->angular_acceleration.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->angular_acceleration.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_angular_acceleration.data.nCount, 1, 9);
	                    	
	                    for(i1=0; (i1 < (int)pVal->cov_angular_acceleration.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->cov_angular_acceleration.data.arr[i1]);
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_ACN_Decode(asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode acceleration */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA;
	    pVal->acceleration.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->acceleration.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->acceleration.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode cov_acceleration */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA;
	        pVal->cov_acceleration.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->cov_acceleration.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_acceleration.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM;
	        }
	        if (ret) {
	            /*Decode angular_acceleration */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA;
	            pVal->angular_acceleration.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->angular_acceleration.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_acceleration.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA;
	                pVal->cov_angular_acceleration.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->cov_angular_acceleration.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_angular_acceleration.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM;
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Wrench_m_Initialize(asn1SccBase_samples_Wrench_m* pVal)
{


	/*set force */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->torque)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Wrench_m_IsConstraintValid(const asn1SccBase_samples_Wrench_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA;
    for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
    {
    	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA;
        for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM;
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TIME_MICROSECONDS;
        }
    }

	return ret;
}

flag asn1SccBase_samples_Wrench_m_Encode(const asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrench_m_Decode(asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_Wrench_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Wrench_m_ACN_Encode(const asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->force.data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeReal(pBitStrm, pVal->force.data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode torque */
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->torque.data.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeReal(pBitStrm, pVal->torque.data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrench_m_ACN_Decode(asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode force */
	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_M_FORCE_DATA;
	pVal->force.data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->force.data.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->force.data.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM;
	}
	if (ret) {
	    /*Decode torque */
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_M_TORQUE_DATA;
	    pVal->torque.data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->torque.data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->torque.data.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM;
	    }
	    if (ret) {
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCH_M_TIME_MICROSECONDS;
	    }
	}

    return ret && asn1SccBase_samples_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Pointcloud_m_points_Initialize(asn1SccBase_samples_Pointcloud_m_points* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccWrappers_Vector3d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Pointcloud_m_colors_Initialize(asn1SccBase_samples_Pointcloud_m_colors* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccWrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Pointcloud_m_Initialize(asn1SccBase_samples_Pointcloud_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set points */
	asn1SccBase_samples_Pointcloud_m_points_Initialize((&(pVal->points)));
	/*set colors */
	asn1SccBase_samples_Pointcloud_m_colors_Initialize((&(pVal->colors)));
}

flag asn1SccBase_samples_Pointcloud_m_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS;
        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++) 
        {
        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA;
        	for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM;
        	}

        }

        if (ret) {
            ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS;
            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++) 
            {
            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA;
            	for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++) 
            	{
            		ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
            		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM;
            	}

            }

        }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_Encode(const asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccWrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccWrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pointcloud_m_Decode(asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccWrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Pointcloud_m_ACN_Encode(const asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.arr[i1].data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->points.arr[i1].data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->points.arr[i1].data.arr[i2]);
	        	}
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	/*Encode data */
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.arr[i1].data.nCount, 1, 4);
	            		
	            	for(i2=0; (i2 < (int)pVal->colors.arr[i1].data.nCount) && ret; i2++) 
	            	{
	            		BitStream_EncodeReal(pBitStrm, pVal->colors.arr[i1].data.arr[i2]);
	            	}
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Pointcloud_m_ACN_Decode(asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA;
	    	pVal->points.arr[i1].data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->points.arr[i1].data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->points.arr[i1].data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM;
	    	}
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	/*Decode data */
	        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA;
	        	pVal->colors.arr[i1].data.nCount = (long)nCount;
	        		
	        	for(i2=0; (i2 < (int)pVal->colors.arr[i1].data.nCount) && ret; i2++) 
	        	{
	        		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->colors.arr[i1].data.arr[i2])));
	        		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM;
	        	}
	        }
	    }
	}

    return ret && asn1SccBase_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_String_Initialize(asn1SccT_String* pVal)
{

	memset(pVal->arr, 0x0, 40);

}

flag asn1SccT_String_IsConstraintValid(const asn1SccT_String* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((0 <= pVal->nCount) && (pVal->nCount <= 40));
    *pErrCode = ret ? 0 :  ERR_T_STRING;

	return ret;
}

flag asn1SccT_String_Encode(const asn1SccT_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccT_String_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccT_String_Decode(asn1SccT_String* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
	}

	return ret  && asn1SccT_String_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_String_ACN_Encode(const asn1SccT_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccT_String_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	
    return ret;
}

flag asn1SccT_String_ACN_Decode(asn1SccT_String* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_STRING;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_STRING;
	}

    return ret && asn1SccT_String_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointLimits_names_Initialize(asn1SccBase_JointLimits_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointLimits_elements_Initialize(asn1SccBase_JointLimits_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointLimitRange_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointLimits_Initialize(asn1SccBase_JointLimits* pVal)
{


	/*set names */
	asn1SccBase_JointLimits_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_JointLimits_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_JointLimits_IsConstraintValid(const asn1SccBase_JointLimits *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION;
        	if (ret) {
        	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION;
        	            }
        	        }
        	    }
        	}
        	if (ret) {
        	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW;
        	                if (ret) {
        	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
        	                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION;
        	                }
        	            }
        	        }
        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_JointLimits_Encode(const asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointLimits_Decode(asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_JointLimits_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointLimits_ACN_Encode(const asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode min */
	        	/*Encode position */
	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.position);
	        	if (ret) {
	        	    /*Encode speed */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.speed);
	        	    if (ret) {
	        	        /*Encode effort */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.effort);
	        	        if (ret) {
	        	            /*Encode raw */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.raw);
	        	            if (ret) {
	        	                /*Encode acceleration */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.acceleration);
	        	            }
	        	        }
	        	    }
	        	}
	        	if (ret) {
	        	    /*Encode max */
	        	    /*Encode position */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.position);
	        	    if (ret) {
	        	        /*Encode speed */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.speed);
	        	        if (ret) {
	        	            /*Encode effort */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.effort);
	        	            if (ret) {
	        	                /*Encode raw */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.raw);
	        	                if (ret) {
	        	                    /*Encode acceleration */
	        	                    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.acceleration);
	        	                }
	        	            }
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointLimits_ACN_Decode(asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode min */
	    	/*Decode position */
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.position)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION;
	    	if (ret) {
	    	    /*Decode speed */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.speed)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED;
	    	    if (ret) {
	    	        /*Decode effort */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.effort)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT;
	    	        if (ret) {
	    	            /*Decode raw */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.raw)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW;
	    	            if (ret) {
	    	                /*Decode acceleration */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.acceleration)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION;
	    	            }
	    	        }
	    	    }
	    	}
	    	if (ret) {
	    	    /*Decode max */
	    	    /*Decode position */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.position)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION;
	    	    if (ret) {
	    	        /*Decode speed */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.speed)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED;
	    	        if (ret) {
	    	            /*Decode effort */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.effort)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT;
	    	            if (ret) {
	    	                /*Decode raw */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.raw)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW;
	    	                if (ret) {
	    	                    /*Decode acceleration */
	    	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.acceleration)));
	    	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION;
	    	                }
	    	            }
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_JointLimits_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointTransform_Initialize(asn1SccBase_JointTransform* pVal)
{


	/*set sourceframe */
	asn1SccT_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	asn1SccT_String_Initialize((&(pVal->targetframe)));
	/*set rotationaxis */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
}

flag asn1SccBase_JointTransform_IsConstraintValid(const asn1SccBase_JointTransform *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((0 <= pVal->sourceframe.nCount) && (pVal->sourceframe.nCount <= 40));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_SOURCEFRAME;
    if (ret) {
        ret = ((0 <= pVal->targetframe.nCount) && (pVal->targetframe.nCount <= 40));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_TARGETFRAME;
        if (ret) {
            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA;
            for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_JointTransform_Encode(const asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = asn1SccT_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = asn1SccT_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransform_Decode(asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = asn1SccT_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = asn1SccT_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_JointTransform_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointTransform_ACN_Encode(const asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->sourceframe.nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->sourceframe.arr[i1]);
	    }
	    if (ret) {
	        /*Encode targetframe */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->targetframe.nCount, 0, 40);
	        	
	        for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->targetframe.arr[i1]);
	        }
	        if (ret) {
	            /*Encode rotationaxis */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->rotationaxis.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->rotationaxis.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->rotationaxis.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransform_ACN_Decode(asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode sourceframe */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_SOURCEFRAME;
	pVal->sourceframe.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->sourceframe.arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_SOURCEFRAME;
	}
	if (ret) {
	    /*Decode targetframe */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_TARGETFRAME;
	    pVal->targetframe.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->targetframe.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_TARGETFRAME;
	    }
	    if (ret) {
	        /*Decode rotationaxis */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA;
	        pVal->rotationaxis.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->rotationaxis.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rotationaxis.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointTransformVector_names_Initialize(asn1SccBase_JointTransformVector_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointTransformVector_elements_Initialize(asn1SccBase_JointTransformVector_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointTransform_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointTransformVector_Initialize(asn1SccBase_JointTransformVector* pVal)
{


	/*set names */
	asn1SccBase_JointTransformVector_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_JointTransformVector_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_JointTransformVector_IsConstraintValid(const asn1SccBase_JointTransformVector *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((0 <= pVal->elements.arr[i1].sourceframe.nCount) && (pVal->elements.arr[i1].sourceframe.nCount <= 40));
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME;
        	if (ret) {
        	    ret = ((0 <= pVal->elements.arr[i1].targetframe.nCount) && (pVal->elements.arr[i1].targetframe.nCount <= 40));
        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME;
        	    if (ret) {
        	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA;
        	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
        	        {
        	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
        	        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
        	        }

        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_JointTransformVector_Encode(const asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransformVector_Decode(asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_JointTransformVector_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointTransformVector_ACN_Encode(const asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode sourceframe */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].sourceframe.nCount, 0, 40);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	        	{
	        		BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].sourceframe.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode targetframe */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].targetframe.nCount, 0, 40);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].targetframe.arr[i2]);
	        	    }
	        	    if (ret) {
	        	        /*Encode rotationaxis */
	        	        /*Encode data */
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.nCount, 1, 3);
	        	        	
	        	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	        	        {
	        	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.arr[i2]);
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransformVector_ACN_Decode(asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode sourceframe */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME;
	    	pVal->elements.arr[i1].sourceframe.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].sourceframe.arr[i2])); 
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME;
	    	}
	    	if (ret) {
	    	    /*Decode targetframe */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME;
	    	    pVal->elements.arr[i1].targetframe.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].targetframe.arr[i2])); 
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME;
	    	    }
	    	    if (ret) {
	    	        /*Decode rotationaxis */
	    	        /*Decode data */
	    	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA;
	    	        pVal->elements.arr[i1].rotationaxis.data.nCount = (long)nCount;
	    	        	
	    	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	    	        {
	    	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].rotationaxis.data.arr[i2])));
	    	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_JointTransformVector_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_Base_JointTransform_names_Initialize(asn1SccBase_NamedVector_Base_JointTransform_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointTransform_elements_Initialize(asn1SccBase_NamedVector_Base_JointTransform_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointTransform_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointTransform_Initialize(asn1SccBase_NamedVector_Base_JointTransform* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_Base_JointTransform_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_NamedVector_Base_JointTransform_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((0 <= pVal->elements.arr[i1].sourceframe.nCount) && (pVal->elements.arr[i1].sourceframe.nCount <= 40));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME;
        	if (ret) {
        	    ret = ((0 <= pVal->elements.arr[i1].targetframe.nCount) && (pVal->elements.arr[i1].targetframe.nCount <= 40));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME;
        	    if (ret) {
        	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
        	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA;
        	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
        	        {
        	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
        	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
        	        }

        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_Encode(const asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_Decode(asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_Base_JointTransform_ACN_Encode(const asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode sourceframe */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].sourceframe.nCount, 0, 40);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	        	{
	        		BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].sourceframe.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode targetframe */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].targetframe.nCount, 0, 40);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].targetframe.arr[i2]);
	        	    }
	        	    if (ret) {
	        	        /*Encode rotationaxis */
	        	        /*Encode data */
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.nCount, 1, 3);
	        	        	
	        	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	        	        {
	        	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.arr[i2]);
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_ACN_Decode(asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode sourceframe */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME;
	    	pVal->elements.arr[i1].sourceframe.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].sourceframe.arr[i2])); 
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME;
	    	}
	    	if (ret) {
	    	    /*Decode targetframe */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME;
	    	    pVal->elements.arr[i1].targetframe.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].targetframe.arr[i2])); 
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME;
	    	    }
	    	    if (ret) {
	    	        /*Decode rotationaxis */
	    	        /*Decode data */
	    	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA;
	    	        pVal->elements.arr[i1].rotationaxis.data.nCount = (long)nCount;
	    	        	
	    	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	    	        {
	    	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].rotationaxis.data.arr[i2])));
	    	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointsTrajectory_names_Initialize(asn1SccBase_JointsTrajectory_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointsTrajectory_elements_Initialize(asn1SccBase_JointsTrajectory_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointTrajectory_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointsTrajectory_times_val_Initialize(asn1SccBase_JointsTrajectory_times_val* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointsTrajectory_Initialize(asn1SccBase_JointsTrajectory* pVal)
{


	/*set names */
	asn1SccBase_JointsTrajectory_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_JointsTrajectory_elements_Initialize((&(pVal->elements)));
	/*set times_val */
	asn1SccBase_JointsTrajectory_times_val_Initialize((&(pVal->times_val)));
}

flag asn1SccBase_JointsTrajectory_IsConstraintValid(const asn1SccBase_JointsTrajectory *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
        		if (ret) {
        		    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
        		    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
        		    if (ret) {
        		        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
        		        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
        		        if (ret) {
        		            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
        		            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
        		            if (ret) {
        		                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
        		                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
        		            }
        		        }
        		    }
        		}
        	}

        }

        if (ret) {
            ret = ((1 <= pVal->times_val.nCount) && (pVal->times_val.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL;
            for(i1 = 0; ret && i1 < pVal->times_val.nCount; i1++) 
            {
            	ret = TRUE;
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_MICROSECONDS;
            }

        }
    }

	return ret;
}

flag asn1SccBase_JointsTrajectory_Encode(const asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode times_val */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccBase_Time_Encode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointsTrajectory_Decode(asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode times_val */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL;
	        pVal->times_val.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Time_Decode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_JointsTrajectory_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointsTrajectory_ACN_Encode(const asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].nCount, 1, 200);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].nCount) && ret; i2++) 
	        	{
	        		/*Encode position */
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].position);
	        		if (ret) {
	        		    /*Encode speed */
	        		    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].speed);
	        		    if (ret) {
	        		        /*Encode effort */
	        		        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].effort);
	        		        if (ret) {
	        		            /*Encode raw */
	        		            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].raw);
	        		            if (ret) {
	        		                /*Encode acceleration */
	        		                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].acceleration);
	        		            }
	        		        }
	        		    }
	        		}
	        	}
	        }
	        if (ret) {
	            /*Encode times_val */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	            {
	            	/*Encode microseconds */
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.arr[i1].microseconds, LLONG_MIN, 9223372036854775807LL);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointsTrajectory_ACN_Decode(asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM;
	    	pVal->elements.arr[i1].nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].nCount) && ret; i2++) 
	    	{
	    		/*Decode position */
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].position)));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
	    		if (ret) {
	    		    /*Decode speed */
	    		    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].speed)));
	    		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
	    		    if (ret) {
	    		        /*Decode effort */
	    		        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].effort)));
	    		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
	    		        if (ret) {
	    		            /*Decode raw */
	    		            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].raw)));
	    		            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
	    		            if (ret) {
	    		                /*Decode acceleration */
	    		                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].acceleration)));
	    		                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
	    		            }
	    		        }
	    		    }
	    		}
	    	}
	    }
	    if (ret) {
	        /*Decode times_val */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL;
	        pVal->times_val.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	        {
	        	/*Decode microseconds */
	        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->times_val.arr[i1].microseconds)), LLONG_MIN, 9223372036854775807LL);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_MICROSECONDS;
	        }
	    }
	}

    return ret && asn1SccBase_JointsTrajectory_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_Base_JointLimitRange_names_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointLimitRange_elements_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointLimitRange_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointLimitRange_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_Base_JointLimitRange_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_NamedVector_Base_JointLimitRange_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION;
        	if (ret) {
        	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION;
        	            }
        	        }
        	    }
        	}
        	if (ret) {
        	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW;
        	                if (ret) {
        	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
        	                    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION;
        	                }
        	            }
        	        }
        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_Encode(const asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_Decode(asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_ACN_Encode(const asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode min */
	        	/*Encode position */
	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.position);
	        	if (ret) {
	        	    /*Encode speed */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.speed);
	        	    if (ret) {
	        	        /*Encode effort */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.effort);
	        	        if (ret) {
	        	            /*Encode raw */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.raw);
	        	            if (ret) {
	        	                /*Encode acceleration */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].min.acceleration);
	        	            }
	        	        }
	        	    }
	        	}
	        	if (ret) {
	        	    /*Encode max */
	        	    /*Encode position */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.position);
	        	    if (ret) {
	        	        /*Encode speed */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.speed);
	        	        if (ret) {
	        	            /*Encode effort */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.effort);
	        	            if (ret) {
	        	                /*Encode raw */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.raw);
	        	                if (ret) {
	        	                    /*Encode acceleration */
	        	                    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].max.acceleration);
	        	                }
	        	            }
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_ACN_Decode(asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode min */
	    	/*Decode position */
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.position)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION;
	    	if (ret) {
	    	    /*Decode speed */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.speed)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED;
	    	    if (ret) {
	    	        /*Decode effort */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.effort)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT;
	    	        if (ret) {
	    	            /*Decode raw */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.raw)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW;
	    	            if (ret) {
	    	                /*Decode acceleration */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].min.acceleration)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION;
	    	            }
	    	        }
	    	    }
	    	}
	    	if (ret) {
	    	    /*Decode max */
	    	    /*Decode position */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.position)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION;
	    	    if (ret) {
	    	        /*Decode speed */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.speed)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED;
	    	        if (ret) {
	    	            /*Decode effort */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.effort)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT;
	    	            if (ret) {
	    	                /*Decode raw */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.raw)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW;
	    	                if (ret) {
	    	                    /*Decode acceleration */
	    	                    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].max.acceleration)));
	    	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION;
	    	                }
	    	            }
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_Base_JointState_names_Initialize(asn1SccBase_NamedVector_Base_JointState_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointState_Initialize(asn1SccBase_NamedVector_Base_JointState* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_Base_JointState_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_JointTrajectory_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION;
        	if (ret) {
        	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION;
        	            }
        	        }
        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_Encode(const asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_Decode(asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_Base_JointState_ACN_Encode(const asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode position */
	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].position);
	        	if (ret) {
	        	    /*Encode speed */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].speed);
	        	    if (ret) {
	        	        /*Encode effort */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].effort);
	        	        if (ret) {
	        	            /*Encode raw */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].raw);
	        	            if (ret) {
	        	                /*Encode acceleration */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].acceleration);
	        	            }
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_ACN_Decode(asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode position */
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].position)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION;
	    	if (ret) {
	    	    /*Decode speed */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].speed)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED;
	    	    if (ret) {
	    	        /*Decode effort */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].effort)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT;
	    	        if (ret) {
	    	            /*Decode raw */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].raw)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW;
	    	            if (ret) {
	    	                /*Decode acceleration */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].acceleration)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION;
	    	            }
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_Base_Wrench_names_Initialize(asn1SccBase_NamedVector_Base_Wrench_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_Wrench_elements_Initialize(asn1SccBase_NamedVector_Base_Wrench_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Wrench_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_Wrench_Initialize(asn1SccBase_NamedVector_Base_Wrench* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_Base_Wrench_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_NamedVector_Base_Wrench_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM;
        	}

        	if (ret) {
        	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA;
        	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM;
        	    }

        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_Encode(const asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_Decode(asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_Base_Wrench_ACN_Encode(const asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode force */
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].force.data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].force.data.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode torque */
	        	    /*Encode data */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].torque.data.nCount, 1, 3);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].torque.data.arr[i2]);
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_ACN_Decode(asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode force */
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA;
	    	pVal->elements.arr[i1].force.data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].force.data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM;
	    	}
	    	if (ret) {
	    	    /*Decode torque */
	    	    /*Decode data */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA;
	    	    pVal->elements.arr[i1].torque.data.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].torque.data.arr[i2])));
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM;
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_Base_JointTrajectory_names_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointTrajectory_elements_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointTrajectory_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_Base_JointTrajectory_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_Base_JointTrajectory_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_NamedVector_Base_JointTrajectory_elements_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
        		if (ret) {
        		    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
        		    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
        		    if (ret) {
        		        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
        		        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
        		        if (ret) {
        		            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
        		            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
        		            if (ret) {
        		                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
        		                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
        		            }
        		        }
        		    }
        		}
        	}

        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_Encode(const asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_Decode(asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_ACN_Encode(const asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].nCount, 1, 200);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].nCount) && ret; i2++) 
	        	{
	        		/*Encode position */
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].position);
	        		if (ret) {
	        		    /*Encode speed */
	        		    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].speed);
	        		    if (ret) {
	        		        /*Encode effort */
	        		        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].effort);
	        		        if (ret) {
	        		            /*Encode raw */
	        		            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].raw);
	        		            if (ret) {
	        		                /*Encode acceleration */
	        		                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].arr[i2].acceleration);
	        		            }
	        		        }
	        		    }
	        		}
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_ACN_Decode(asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM;
	    	pVal->elements.arr[i1].nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].nCount) && ret; i2++) 
	    	{
	    		/*Decode position */
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].position)));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
	    		if (ret) {
	    		    /*Decode speed */
	    		    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].speed)));
	    		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
	    		    if (ret) {
	    		        /*Decode effort */
	    		        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].effort)));
	    		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
	    		        if (ret) {
	    		            /*Decode raw */
	    		            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].raw)));
	    		            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
	    		            if (ret) {
	    		                /*Decode acceleration */
	    		                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].arr[i2].acceleration)));
	    		                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
	    		            }
	    		        }
	    		    }
	    		}
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_commands_Joints_names_Initialize(asn1SccBase_commands_Joints_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_commands_Joints_Initialize(asn1SccBase_commands_Joints* pVal)
{


	/*set names */
	asn1SccBase_commands_Joints_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_JointTrajectory_Initialize((&(pVal->elements)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_commands_Joints_IsConstraintValid(const asn1SccBase_commands_Joints *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION;
        	if (ret) {
        	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
        	    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED;
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT;
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW;
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION;
        	            }
        	        }
        	    }
        	}
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_TIME_MICROSECONDS;
        }
    }

	return ret;
}

flag asn1SccBase_commands_Joints_Encode(const asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Joints_Decode(asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_commands_Joints_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_commands_Joints_ACN_Encode(const asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode position */
	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].position);
	        	if (ret) {
	        	    /*Encode speed */
	        	    BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].speed);
	        	    if (ret) {
	        	        /*Encode effort */
	        	        BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].effort);
	        	        if (ret) {
	        	            /*Encode raw */
	        	            BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].raw);
	        	            if (ret) {
	        	                /*Encode acceleration */
	        	                BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].acceleration);
	        	            }
	        	        }
	        	    }
	        	}
	        }
	        if (ret) {
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_commands_Joints_ACN_Decode(asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode position */
	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].position)));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION;
	    	if (ret) {
	    	    /*Decode speed */
	    	    ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].speed)));
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED;
	    	    if (ret) {
	    	        /*Decode effort */
	    	        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].effort)));
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT;
	    	        if (ret) {
	    	            /*Decode raw */
	    	            ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].raw)));
	    	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW;
	    	            if (ret) {
	    	                /*Decode acceleration */
	    	                ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].acceleration)));
	    	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION;
	    	            }
	    	        }
	    	    }
	    	}
	    }
	    if (ret) {
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_COMMANDS_JOINTS_TIME_MICROSECONDS;
	    }
	}

    return ret && asn1SccBase_commands_Joints_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_RigidBodyState_Initialize(asn1SccBase_samples_RigidBodyState* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set sourceframe */
	asn1SccT_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	asn1SccT_String_Initialize((&(pVal->targetframe)));
	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set cov_position */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_position)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov_orientation */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
	/*set velocity */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->velocity)));
	/*set cov_velocity */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
	/*set angular_velocity */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
	/*set cov_angular_velocity */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
}

flag asn1SccBase_samples_RigidBodyState_IsConstraintValid(const asn1SccBase_samples_RigidBodyState *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_TIME_MICROSECONDS;
    if (ret) {
        ret = ((0 <= pVal->sourceframe.nCount) && (pVal->sourceframe.nCount <= 40));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME;
        if (ret) {
            ret = ((0 <= pVal->targetframe.nCount) && (pVal->targetframe.nCount <= 40));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME;
            if (ret) {
                ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA;
                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA;
                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM;
                    }

                    if (ret) {
                        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM;
                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM;
                        }

                        if (ret) {
                            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE;
                        }
                        if (ret) {
                            ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA;
                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM;
                            }

                            if (ret) {
                                ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA;
                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM;
                                }

                                if (ret) {
                                    ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA;
                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++) 
                                    {
                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM;
                                    }

                                    if (ret) {
                                        ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA;
                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++) 
                                        {
                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM;
                                        }

                                        if (ret) {
                                            ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
                                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA;
                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++) 
                                            {
                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM;
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_Encode(const asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = asn1SccT_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = asn1SccT_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyState_Decode(asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = asn1SccT_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = asn1SccT_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_RigidBodyState_ACN_Encode(const asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode sourceframe */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->sourceframe.nCount, 0, 40);
	        	
	        for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->sourceframe.arr[i1]);
	        }
	        if (ret) {
	            /*Encode targetframe */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->targetframe.nCount, 0, 40);
	            	
	            for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	            {
	            	BitStream_AppendByte0(pBitStrm, pVal->targetframe.arr[i1]);
	            }
	            if (ret) {
	                /*Encode position */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov_position */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_position.data.nCount, 1, 9);
	                    	
	                    for(i1=0; (i1 < (int)pVal->cov_position.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->cov_position.data.arr[i1]);
	                    }
	                    if (ret) {
	                        /*Encode orientation */
	                        /*Encode im */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	                        	
	                        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	                        }
	                        if (ret) {
	                            /*Encode re */
	                            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	                        }
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            /*Encode data */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_orientation.data.nCount, 1, 9);
	                            	
	                            for(i1=0; (i1 < (int)pVal->cov_orientation.data.nCount) && ret; i1++) 
	                            {
	                            	BitStream_EncodeReal(pBitStrm, pVal->cov_orientation.data.arr[i1]);
	                            }
	                            if (ret) {
	                                /*Encode velocity */
	                                /*Encode data */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.data.nCount, 1, 3);
	                                	
	                                for(i1=0; (i1 < (int)pVal->velocity.data.nCount) && ret; i1++) 
	                                {
	                                	BitStream_EncodeReal(pBitStrm, pVal->velocity.data.arr[i1]);
	                                }
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    /*Encode data */
	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_velocity.data.nCount, 1, 9);
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->cov_velocity.data.nCount) && ret; i1++) 
	                                    {
	                                    	BitStream_EncodeReal(pBitStrm, pVal->cov_velocity.data.arr[i1]);
	                                    }
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        /*Encode data */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular_velocity.data.nCount, 1, 3);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->angular_velocity.data.nCount) && ret; i1++) 
	                                        {
	                                        	BitStream_EncodeReal(pBitStrm, pVal->angular_velocity.data.arr[i1]);
	                                        }
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            /*Encode data */
	                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_angular_velocity.data.nCount, 1, 9);
	                                            	
	                                            for(i1=0; (i1 < (int)pVal->cov_angular_velocity.data.nCount) && ret; i1++) 
	                                            {
	                                            	BitStream_EncodeReal(pBitStrm, pVal->cov_angular_velocity.data.arr[i1]);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyState_ACN_Decode(asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode sourceframe */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME;
	    pVal->sourceframe.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->sourceframe.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME;
	    }
	    if (ret) {
	        /*Decode targetframe */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME;
	        pVal->targetframe.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->targetframe.arr[i1])); 
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME;
	        }
	        if (ret) {
	            /*Decode position */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA;
	            pVal->position.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov_position */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA;
	                pVal->cov_position.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->cov_position.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_position.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM;
	                }
	                if (ret) {
	                    /*Decode orientation */
	                    /*Decode im */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM;
	                    pVal->orientation.im.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM;
	                    }
	                    if (ret) {
	                        /*Decode re */
	                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE;
	                    }
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        /*Decode data */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA;
	                        pVal->cov_orientation.data.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->cov_orientation.data.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_orientation.data.arr[i1])));
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM;
	                        }
	                        if (ret) {
	                            /*Decode velocity */
	                            /*Decode data */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA;
	                            pVal->velocity.data.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->velocity.data.nCount) && ret; i1++) 
	                            {
	                            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.data.arr[i1])));
	                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM;
	                            }
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                /*Decode data */
	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA;
	                                pVal->cov_velocity.data.nCount = (long)nCount;
	                                	
	                                for(i1=0; (i1 < (int)pVal->cov_velocity.data.nCount) && ret; i1++) 
	                                {
	                                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_velocity.data.arr[i1])));
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM;
	                                }
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    /*Decode data */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA;
	                                    pVal->angular_velocity.data.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->angular_velocity.data.nCount) && ret; i1++) 
	                                    {
	                                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_velocity.data.arr[i1])));
	                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM;
	                                    }
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        /*Decode data */
	                                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA;
	                                        pVal->cov_angular_velocity.data.nCount = (long)nCount;
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->cov_angular_velocity.data.nCount) && ret; i1++) 
	                                        {
	                                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_angular_velocity.data.arr[i1])));
	                                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Wrenches_names_Initialize(asn1SccBase_samples_Wrenches_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Wrenches_elements_Initialize(asn1SccBase_samples_Wrenches_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_Wrench_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Wrenches_Initialize(asn1SccBase_samples_Wrenches* pVal)
{


	/*set names */
	asn1SccBase_samples_Wrenches_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccBase_samples_Wrenches_elements_Initialize((&(pVal->elements)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Wrenches_IsConstraintValid(const asn1SccBase_samples_Wrenches *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM;
        	}

        	if (ret) {
        	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
        	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA;
        	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM;
        	    }

        	}
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_TIME_MICROSECONDS;
        }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_Encode(const asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = asn1SccBase_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrenches_Decode(asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_Wrenches_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Wrenches_ACN_Encode(const asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode force */
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].force.data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].force.data.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode torque */
	        	    /*Encode data */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].torque.data.nCount, 1, 3);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].torque.data.arr[i2]);
	        	    }
	        	}
	        }
	        if (ret) {
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrenches_ACN_Decode(asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode force */
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA;
	    	pVal->elements.arr[i1].force.data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].force.data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM;
	    	}
	    	if (ret) {
	    	    /*Decode torque */
	    	    /*Decode data */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA;
	    	    pVal->elements.arr[i1].torque.data.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].torque.data.arr[i2])));
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM;
	    	    }
	    	}
	    }
	    if (ret) {
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_TIME_MICROSECONDS;
	    }
	}

    return ret && asn1SccBase_samples_Wrenches_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_frame_attrib_t_Initialize(asn1SccBase_samples_frame_frame_attrib_t* pVal)
{


	/*set data */
	asn1SccT_String_Initialize((&(pVal->data)));
	/*set name_val */
	asn1SccT_String_Initialize((&(pVal->name_val)));
}

flag asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_attrib_t *pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((0 <= pVal->data.nCount) && (pVal->data.nCount <= 40));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA;
    if (ret) {
        ret = ((0 <= pVal->name_val.nCount) && (pVal->name_val.nCount <= 40));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL;
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_attrib_t_Encode(const asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccT_String_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode name_val */
	        ret = asn1SccT_String_Encode((&(pVal->name_val)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_attrib_t_Decode(asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccT_String_Decode((&(pVal->data)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode name_val */
	    ret = asn1SccT_String_Decode((&(pVal->name_val)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_frame_attrib_t_ACN_Encode(const asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
	    }
	    if (ret) {
	        /*Encode name_val */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->name_val.nCount, 0, 40);
	        	
	        for(i1=0; (i1 < (int)pVal->name_val.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->name_val.arr[i1]);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_frame_attrib_t_ACN_Decode(asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA;
	}
	if (ret) {
	    /*Decode name_val */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL;
	    pVal->name_val.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->name_val.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->name_val.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL;
	    }
	}

    return ret && asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_Frame_image_Initialize(asn1SccBase_samples_frame_Frame_image* pVal)
{

	memset(pVal->arr, 0x0, 200);

}
void asn1SccBase_samples_frame_Frame_attributes_Initialize(asn1SccBase_samples_frame_Frame_attributes* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_samples_frame_frame_attrib_t_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_frame_Frame_Initialize(asn1SccBase_samples_frame_Frame* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set received_time */
	asn1SccBase_Time_Initialize((&(pVal->received_time)));
	/*set image */
	asn1SccBase_samples_frame_Frame_image_Initialize((&(pVal->image)));
	/*set attributes */
	asn1SccBase_samples_frame_Frame_attributes_Initialize((&(pVal->attributes)));
	/*set size_val */
	asn1SccBase_samples_frame_frame_size_t_Initialize((&(pVal->size_val)));
	/*set data_depth */
	asn1SccT_UInt32_Initialize((&(pVal->data_depth)));
	/*set pixel_size */
	asn1SccT_UInt32_Initialize((&(pVal->pixel_size)));
	/*set row_size */
	asn1SccT_UInt32_Initialize((&(pVal->row_size)));
	/*set frame_mode */
	asn1SccBase_samples_frame_frame_mode_t_Initialize((&(pVal->frame_mode)));
	/*set frame_status */
	asn1SccBase_samples_frame_frame_status_t_Initialize((&(pVal->frame_status)));
}

flag asn1SccBase_samples_frame_Frame_IsConstraintValid(const asn1SccBase_samples_frame_Frame *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_TIME_MICROSECONDS;
    if (ret) {
        ret = TRUE;
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_MICROSECONDS;
        if (ret) {
            ret = ((1 <= pVal->image.nCount) && (pVal->image.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE;
            if (ret) {
                ret = ((1 <= pVal->attributes.nCount) && (pVal->attributes.nCount <= 200));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
                for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++) 
                {
                	ret = ((0 <= pVal->attributes.arr[i1].data.nCount) && (pVal->attributes.arr[i1].data.nCount <= 40));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA;
                	if (ret) {
                	    ret = ((0 <= pVal->attributes.arr[i1].name_val.nCount) && (pVal->attributes.arr[i1].name_val.nCount <= 40));
                	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL;
                	}
                }

                if (ret) {
                    ret = (pVal->size_val.width <= 65535UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH;
                    if (ret) {
                        ret = (pVal->size_val.height <= 65535UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT;
                    }
                    if (ret) {
                        ret = (pVal->data_depth <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH;
                        if (ret) {
                            ret = (pVal->pixel_size <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE;
                            if (ret) {
                                ret = (pVal->row_size <= 4294967295UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE;
                                if (ret) {
                                    ret = (((((((((((((((((((((((((((((((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_png)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->frame_mode == asn1Sccbase_samples_frame_frame_mode_t_raw_modes)));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;
                                    if (ret) {
                                        ret = (((((pVal->frame_status == asn1Sccbase_samples_frame_frame_status_t_status_empty)) || ((pVal->frame_status == asn1Sccbase_samples_frame_frame_status_t_status_invalid)))) || ((pVal->frame_status == asn1Sccbase_samples_frame_frame_status_t_status_valid)));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_frame_Frame_Encode(const asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode received_time */
	        ret = asn1SccBase_Time_Encode((&(pVal->received_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode image */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->image.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	            {
	            	BitStream_AppendByte0(pBitStrm, pVal->image.arr[i1]);
	            }
	            if (ret) {
	                /*Encode attributes */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 1, 200);
	                	
	                for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	                {
	                	ret = asn1SccBase_samples_frame_frame_attrib_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
	                }
	                if (ret) {
	                    /*Encode size_val */
	                    ret = asn1SccBase_samples_frame_frame_size_t_Encode((&(pVal->size_val)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data_depth */
	                        ret = asn1SccT_UInt32_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode pixel_size */
	                            ret = asn1SccT_UInt32_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode row_size */
	                                ret = asn1SccT_UInt32_Encode((&(pVal->row_size)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode frame_mode */
	                                    ret = asn1SccBase_samples_frame_frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode frame_status */
	                                        ret = asn1SccBase_samples_frame_frame_status_t_Encode((&(pVal->frame_status)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_Frame_Decode(asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode received_time */
	    ret = asn1SccBase_Time_Decode((&(pVal->received_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode image */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        pVal->image.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->image.arr[i1])); 
	        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        }
	        if (ret) {
	            /*Decode attributes */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
	            pVal->attributes.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	            {
	            	ret = asn1SccBase_samples_frame_frame_attrib_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
	            }
	            if (ret) {
	                /*Decode size_val */
	                ret = asn1SccBase_samples_frame_frame_size_t_Decode((&(pVal->size_val)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode data_depth */
	                    ret = asn1SccT_UInt32_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode pixel_size */
	                        ret = asn1SccT_UInt32_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode row_size */
	                            ret = asn1SccT_UInt32_Decode((&(pVal->row_size)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode frame_mode */
	                                ret = asn1SccBase_samples_frame_frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode frame_status */
	                                    ret = asn1SccBase_samples_frame_frame_status_t_Decode((&(pVal->frame_status)), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_frame_Frame_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_Frame_ACN_Encode(const asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode received_time */
	        /*Encode microseconds */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->received_time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        if (ret) {
	            /*Encode image */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->image.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	            {
	            	BitStream_AppendByte0(pBitStrm, pVal->image.arr[i1]);
	            }
	            if (ret) {
	                /*Encode attributes */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 1, 200);
	                	
	                for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	                {
	                	/*Encode data */
	                	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.arr[i1].data.nCount, 0, 40);
	                		
	                	for(i2=0; (i2 < (int)pVal->attributes.arr[i1].data.nCount) && ret; i2++) 
	                	{
	                		BitStream_AppendByte0(pBitStrm, pVal->attributes.arr[i1].data.arr[i2]);
	                	}
	                	if (ret) {
	                	    /*Encode name_val */
	                	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.arr[i1].name_val.nCount, 0, 40);
	                	    	
	                	    for(i2=0; (i2 < (int)pVal->attributes.arr[i1].name_val.nCount) && ret; i2++) 
	                	    {
	                	    	BitStream_AppendByte0(pBitStrm, pVal->attributes.arr[i1].name_val.arr[i2]);
	                	    }
	                	}
	                }
	                if (ret) {
	                    /*Encode size_val */
	                    /*Encode width */
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->size_val.width, 0, 65535);
	                    if (ret) {
	                        /*Encode height */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->size_val.height, 0, 65535);
	                    }
	                    if (ret) {
	                        /*Encode data_depth */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->data_depth, 0, 4294967295LL);
	                        if (ret) {
	                            /*Encode pixel_size */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pixel_size, 0, 4294967295LL);
	                            if (ret) {
	                                /*Encode row_size */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->row_size, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode frame_mode */
	                                    switch(pVal->frame_mode) { 
	                                        case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:
	                                            intVal = 0;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:
	                                            intVal = 1;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:
	                                            intVal = 2;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:
	                                            intVal = 3;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:
	                                            intVal = 4;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:
	                                            intVal = 5;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:
	                                            intVal = 6;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:
	                                            intVal = 7;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:
	                                            intVal = 8;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:
	                                            intVal = 9;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_png:
	                                            intVal = 10;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:
	                                            intVal = 11;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:
	                                            intVal = 12;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:
	                                            intVal = 13;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:
	                                            intVal = 14;
	                                            break;
	                                        case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:
	                                            intVal = 15;
	                                            break;
	                                        default:
	                                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                            *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                    }
	                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 15);
	                                    if (ret) {
	                                        /*Encode frame_status */
	                                        switch(pVal->frame_status) { 
	                                            case asn1Sccbase_samples_frame_frame_status_t_status_empty:
	                                                intVal = 0;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_status_t_status_invalid:
	                                                intVal = 1;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_status_t_status_valid:
	                                                intVal = 2;
	                                                break;
	                                            default:
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                        }
	                                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_Frame_ACN_Decode(asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;
	asn1SccUint intVal;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode received_time */
	    /*Decode microseconds */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->received_time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_MICROSECONDS;
	    if (ret) {
	        /*Decode image */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        pVal->image.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->image.arr[i1])); 
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        }
	        if (ret) {
	            /*Decode attributes */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
	            pVal->attributes.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	            {
	            	/*Decode data */
	            	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA;
	            	pVal->attributes.arr[i1].data.nCount = (long)nCount;
	            		
	            	for(i2=0; (i2 < (int)pVal->attributes.arr[i1].data.nCount) && ret; i2++) 
	            	{
	            		ret = BitStream_ReadByte(pBitStrm, &(pVal->attributes.arr[i1].data.arr[i2])); 
	            		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA;
	            	}
	            	if (ret) {
	            	    /*Decode name_val */
	            	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	            	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL;
	            	    pVal->attributes.arr[i1].name_val.nCount = (long)nCount;
	            	    	
	            	    for(i2=0; (i2 < (int)pVal->attributes.arr[i1].name_val.nCount) && ret; i2++) 
	            	    {
	            	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->attributes.arr[i1].name_val.arr[i2])); 
	            	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL;
	            	    }
	            	}
	            }
	            if (ret) {
	                /*Decode size_val */
	                /*Decode width */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->size_val.width)), 0, 65535);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH;
	                if (ret) {
	                    /*Decode height */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->size_val.height)), 0, 65535);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT;
	                }
	                if (ret) {
	                    /*Decode data_depth */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->data_depth)), 0, 4294967295LL);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH;
	                    if (ret) {
	                        /*Decode pixel_size */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pixel_size)), 0, 4294967295LL);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE;
	                        if (ret) {
	                            /*Decode row_size */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->row_size)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE;
	                            if (ret) {
	                                /*Decode frame_mode */
	                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 15);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;
	                                if (ret) {
	                                    switch (intVal) {
	                                        case 0:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	                                            break;
	                                        case 1:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	                                            break;
	                                        case 2:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	                                            break;
	                                        case 3:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	                                            break;
	                                        case 4:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	                                            break;
	                                        case 5:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	                                            break;
	                                        case 6:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	                                            break;
	                                        case 7:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	                                            break;
	                                        case 8:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	                                            break;
	                                        case 9:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	                                            break;
	                                        case 10:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	                                            break;
	                                        case 11:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	                                            break;
	                                        case 12:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	                                            break;
	                                        case 13:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	                                            break;
	                                        case 14:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	                                            break;
	                                        case 15:
	                                            pVal->frame_mode = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	                                            break;
	                                    default:
	                                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                        *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                    }
	                                }
	                                if (ret) {
	                                    /*Decode frame_status */
	                                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;
	                                    if (ret) {
	                                        switch (intVal) {
	                                            case 0:
	                                                pVal->frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	                                                break;
	                                            case 1:
	                                                pVal->frame_status = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	                                                break;
	                                            case 2:
	                                                pVal->frame_status = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	                                                break;
	                                        default:
	                                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                            *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_frame_Frame_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_frame_FramePair_Initialize(asn1SccBase_samples_frame_FramePair* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set first */
	asn1SccBase_samples_frame_Frame_Initialize((&(pVal->first)));
	/*set second */
	asn1SccBase_samples_frame_Frame_Initialize((&(pVal->second)));
	/*set id */
	asn1SccT_UInt32_Initialize((&(pVal->id)));
}

flag asn1SccBase_samples_frame_FramePair_IsConstraintValid(const asn1SccBase_samples_frame_FramePair *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_MICROSECONDS;
    if (ret) {
        ret = TRUE;
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME_MICROSECONDS;
        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME_MICROSECONDS;
            if (ret) {
                ret = ((1 <= pVal->first.image.nCount) && (pVal->first.image.nCount <= 200));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE;
                if (ret) {
                    ret = ((1 <= pVal->first.attributes.nCount) && (pVal->first.attributes.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES;
                    for(i1 = 0; ret && i1 < pVal->first.attributes.nCount; i1++) 
                    {
                    	ret = ((0 <= pVal->first.attributes.arr[i1].data.nCount) && (pVal->first.attributes.arr[i1].data.nCount <= 40));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA;
                    	if (ret) {
                    	    ret = ((0 <= pVal->first.attributes.arr[i1].name_val.nCount) && (pVal->first.attributes.arr[i1].name_val.nCount <= 40));
                    	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL;
                    	}
                    }

                    if (ret) {
                        ret = (pVal->first.size_val.width <= 65535UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH;
                        if (ret) {
                            ret = (pVal->first.size_val.height <= 65535UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT;
                        }
                        if (ret) {
                            ret = (pVal->first.data_depth <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH;
                            if (ret) {
                                ret = (pVal->first.pixel_size <= 4294967295UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE;
                                if (ret) {
                                    ret = (pVal->first.row_size <= 4294967295UL);
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE;
                                    if (ret) {
                                        ret = (((((((((((((((((((((((((((((((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_png)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->first.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_raw_modes)));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;
                                        if (ret) {
                                            ret = (((((pVal->first.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_empty)) || ((pVal->first.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_invalid)))) || ((pVal->first.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_valid)));
                                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME_MICROSECONDS;
            if (ret) {
                ret = TRUE;
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME_MICROSECONDS;
                if (ret) {
                    ret = ((1 <= pVal->second.image.nCount) && (pVal->second.image.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE;
                    if (ret) {
                        ret = ((1 <= pVal->second.attributes.nCount) && (pVal->second.attributes.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES;
                        for(i1 = 0; ret && i1 < pVal->second.attributes.nCount; i1++) 
                        {
                        	ret = ((0 <= pVal->second.attributes.arr[i1].data.nCount) && (pVal->second.attributes.arr[i1].data.nCount <= 40));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA;
                        	if (ret) {
                        	    ret = ((0 <= pVal->second.attributes.arr[i1].name_val.nCount) && (pVal->second.attributes.arr[i1].name_val.nCount <= 40));
                        	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL;
                        	}
                        }

                        if (ret) {
                            ret = (pVal->second.size_val.width <= 65535UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH;
                            if (ret) {
                                ret = (pVal->second.size_val.height <= 65535UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT;
                            }
                            if (ret) {
                                ret = (pVal->second.data_depth <= 4294967295UL);
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH;
                                if (ret) {
                                    ret = (pVal->second.pixel_size <= 4294967295UL);
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE;
                                    if (ret) {
                                        ret = (pVal->second.row_size <= 4294967295UL);
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE;
                                        if (ret) {
                                            ret = (((((((((((((((((((((((((((((((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_png)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->second.frame_mode == asn1Sccbase_samples_frame_frame_mode_t_raw_modes)));
                                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;
                                            if (ret) {
                                                ret = (((((pVal->second.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_empty)) || ((pVal->second.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_invalid)))) || ((pVal->second.frame_status == asn1Sccbase_samples_frame_frame_status_t_status_valid)));
                                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (ret) {
                ret = (pVal->id <= 4294967295UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID;
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_frame_FramePair_Encode(const asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode first */
	        ret = asn1SccBase_samples_frame_Frame_Encode((&(pVal->first)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode second */
	            ret = asn1SccBase_samples_frame_Frame_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode id */
	                ret = asn1SccT_UInt32_Encode((&(pVal->id)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_FramePair_Decode(asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode first */
	    ret = asn1SccBase_samples_frame_Frame_Decode((&(pVal->first)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode second */
	        ret = asn1SccBase_samples_frame_Frame_Decode((&(pVal->second)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode id */
	            ret = asn1SccT_UInt32_Decode((&(pVal->id)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccBase_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_frame_FramePair_ACN_Encode(const asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccUint intVal;
	ret = bCheckConstraints ? asn1SccBase_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode first */
	        /*Encode time */
	        /*Encode microseconds */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        if (ret) {
	            /*Encode received_time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.received_time.microseconds, LLONG_MIN, 9223372036854775807LL);
	            if (ret) {
	                /*Encode image */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.image.nCount, 1, 200);
	                	
	                for(i1=0; (i1 < (int)pVal->first.image.nCount) && ret; i1++) 
	                {
	                	BitStream_AppendByte0(pBitStrm, pVal->first.image.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode attributes */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.attributes.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->first.attributes.nCount) && ret; i1++) 
	                    {
	                    	/*Encode data */
	                    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.attributes.arr[i1].data.nCount, 0, 40);
	                    		
	                    	for(i2=0; (i2 < (int)pVal->first.attributes.arr[i1].data.nCount) && ret; i2++) 
	                    	{
	                    		BitStream_AppendByte0(pBitStrm, pVal->first.attributes.arr[i1].data.arr[i2]);
	                    	}
	                    	if (ret) {
	                    	    /*Encode name_val */
	                    	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->first.attributes.arr[i1].name_val.nCount, 0, 40);
	                    	    	
	                    	    for(i2=0; (i2 < (int)pVal->first.attributes.arr[i1].name_val.nCount) && ret; i2++) 
	                    	    {
	                    	    	BitStream_AppendByte0(pBitStrm, pVal->first.attributes.arr[i1].name_val.arr[i2]);
	                    	    }
	                    	}
	                    }
	                    if (ret) {
	                        /*Encode size_val */
	                        /*Encode width */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->first.size_val.width, 0, 65535);
	                        if (ret) {
	                            /*Encode height */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->first.size_val.height, 0, 65535);
	                        }
	                        if (ret) {
	                            /*Encode data_depth */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->first.data_depth, 0, 4294967295LL);
	                            if (ret) {
	                                /*Encode pixel_size */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->first.pixel_size, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode row_size */
	                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->first.row_size, 0, 4294967295LL);
	                                    if (ret) {
	                                        /*Encode frame_mode */
	                                        switch(pVal->first.frame_mode) { 
	                                            case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:
	                                                intVal = 0;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:
	                                                intVal = 1;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:
	                                                intVal = 2;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:
	                                                intVal = 3;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:
	                                                intVal = 4;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:
	                                                intVal = 5;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:
	                                                intVal = 6;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:
	                                                intVal = 7;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:
	                                                intVal = 8;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:
	                                                intVal = 9;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_png:
	                                                intVal = 10;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:
	                                                intVal = 11;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:
	                                                intVal = 12;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:
	                                                intVal = 13;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:
	                                                intVal = 14;
	                                                break;
	                                            case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:
	                                                intVal = 15;
	                                                break;
	                                            default:
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                        }
	                                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 15);
	                                        if (ret) {
	                                            /*Encode frame_status */
	                                            switch(pVal->first.frame_status) { 
	                                                case asn1Sccbase_samples_frame_frame_status_t_status_empty:
	                                                    intVal = 0;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_status_t_status_invalid:
	                                                    intVal = 1;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_status_t_status_valid:
	                                                    intVal = 2;
	                                                    break;
	                                                default:
	                                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                    *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                            }
	                                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (ret) {
	            /*Encode second */
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.time.microseconds, LLONG_MIN, 9223372036854775807LL);
	            if (ret) {
	                /*Encode received_time */
	                /*Encode microseconds */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.received_time.microseconds, LLONG_MIN, 9223372036854775807LL);
	                if (ret) {
	                    /*Encode image */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.image.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->second.image.nCount) && ret; i1++) 
	                    {
	                    	BitStream_AppendByte0(pBitStrm, pVal->second.image.arr[i1]);
	                    }
	                    if (ret) {
	                        /*Encode attributes */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.attributes.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->second.attributes.nCount) && ret; i1++) 
	                        {
	                        	/*Encode data */
	                        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.attributes.arr[i1].data.nCount, 0, 40);
	                        		
	                        	for(i2=0; (i2 < (int)pVal->second.attributes.arr[i1].data.nCount) && ret; i2++) 
	                        	{
	                        		BitStream_AppendByte0(pBitStrm, pVal->second.attributes.arr[i1].data.arr[i2]);
	                        	}
	                        	if (ret) {
	                        	    /*Encode name_val */
	                        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->second.attributes.arr[i1].name_val.nCount, 0, 40);
	                        	    	
	                        	    for(i2=0; (i2 < (int)pVal->second.attributes.arr[i1].name_val.nCount) && ret; i2++) 
	                        	    {
	                        	    	BitStream_AppendByte0(pBitStrm, pVal->second.attributes.arr[i1].name_val.arr[i2]);
	                        	    }
	                        	}
	                        }
	                        if (ret) {
	                            /*Encode size_val */
	                            /*Encode width */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->second.size_val.width, 0, 65535);
	                            if (ret) {
	                                /*Encode height */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->second.size_val.height, 0, 65535);
	                            }
	                            if (ret) {
	                                /*Encode data_depth */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->second.data_depth, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode pixel_size */
	                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->second.pixel_size, 0, 4294967295LL);
	                                    if (ret) {
	                                        /*Encode row_size */
	                                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->second.row_size, 0, 4294967295LL);
	                                        if (ret) {
	                                            /*Encode frame_mode */
	                                            switch(pVal->second.frame_mode) { 
	                                                case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:
	                                                    intVal = 0;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:
	                                                    intVal = 1;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:
	                                                    intVal = 2;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:
	                                                    intVal = 3;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:
	                                                    intVal = 4;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:
	                                                    intVal = 5;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:
	                                                    intVal = 6;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:
	                                                    intVal = 7;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:
	                                                    intVal = 8;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:
	                                                    intVal = 9;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_png:
	                                                    intVal = 10;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:
	                                                    intVal = 11;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:
	                                                    intVal = 12;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:
	                                                    intVal = 13;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:
	                                                    intVal = 14;
	                                                    break;
	                                                case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:
	                                                    intVal = 15;
	                                                    break;
	                                                default:
	                                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                    *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                            }
	                                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 15);
	                                            if (ret) {
	                                                /*Encode frame_status */
	                                                switch(pVal->second.frame_status) { 
	                                                    case asn1Sccbase_samples_frame_frame_status_t_status_empty:
	                                                        intVal = 0;
	                                                        break;
	                                                    case asn1Sccbase_samples_frame_frame_status_t_status_invalid:
	                                                        intVal = 1;
	                                                        break;
	                                                    case asn1Sccbase_samples_frame_frame_status_t_status_valid:
	                                                        intVal = 2;
	                                                        break;
	                                                    default:
	                                                        ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                        *pErrCode = ERR_ACN_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                                }
	                                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if (ret) {
	                /*Encode id */
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->id, 0, 4294967295LL);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_frame_FramePair_ACN_Decode(asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;
	asn1SccUint intVal;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode first */
	    /*Decode time */
	    /*Decode microseconds */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->first.time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME_MICROSECONDS;
	    if (ret) {
	        /*Decode received_time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->first.received_time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME_MICROSECONDS;
	        if (ret) {
	            /*Decode image */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE;
	            pVal->first.image.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->first.image.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_ReadByte(pBitStrm, &(pVal->first.image.arr[i1])); 
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE;
	            }
	            if (ret) {
	                /*Decode attributes */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES;
	                pVal->first.attributes.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->first.attributes.nCount) && ret; i1++) 
	                {
	                	/*Decode data */
	                	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA;
	                	pVal->first.attributes.arr[i1].data.nCount = (long)nCount;
	                		
	                	for(i2=0; (i2 < (int)pVal->first.attributes.arr[i1].data.nCount) && ret; i2++) 
	                	{
	                		ret = BitStream_ReadByte(pBitStrm, &(pVal->first.attributes.arr[i1].data.arr[i2])); 
	                		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA;
	                	}
	                	if (ret) {
	                	    /*Decode name_val */
	                	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	                	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL;
	                	    pVal->first.attributes.arr[i1].name_val.nCount = (long)nCount;
	                	    	
	                	    for(i2=0; (i2 < (int)pVal->first.attributes.arr[i1].name_val.nCount) && ret; i2++) 
	                	    {
	                	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->first.attributes.arr[i1].name_val.arr[i2])); 
	                	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL;
	                	    }
	                	}
	                }
	                if (ret) {
	                    /*Decode size_val */
	                    /*Decode width */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->first.size_val.width)), 0, 65535);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH;
	                    if (ret) {
	                        /*Decode height */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->first.size_val.height)), 0, 65535);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT;
	                    }
	                    if (ret) {
	                        /*Decode data_depth */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->first.data_depth)), 0, 4294967295LL);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH;
	                        if (ret) {
	                            /*Decode pixel_size */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->first.pixel_size)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE;
	                            if (ret) {
	                                /*Decode row_size */
	                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->first.row_size)), 0, 4294967295LL);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE;
	                                if (ret) {
	                                    /*Decode frame_mode */
	                                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 15);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;
	                                    if (ret) {
	                                        switch (intVal) {
	                                            case 0:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	                                                break;
	                                            case 1:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	                                                break;
	                                            case 2:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	                                                break;
	                                            case 3:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	                                                break;
	                                            case 4:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	                                                break;
	                                            case 5:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	                                                break;
	                                            case 6:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	                                                break;
	                                            case 7:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	                                                break;
	                                            case 8:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	                                                break;
	                                            case 9:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	                                                break;
	                                            case 10:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	                                                break;
	                                            case 11:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	                                                break;
	                                            case 12:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	                                                break;
	                                            case 13:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	                                                break;
	                                            case 14:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	                                                break;
	                                            case 15:
	                                                pVal->first.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	                                                break;
	                                        default:
	                                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                            *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                        }
	                                    }
	                                    if (ret) {
	                                        /*Decode frame_status */
	                                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;
	                                        if (ret) {
	                                            switch (intVal) {
	                                                case 0:
	                                                    pVal->first.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	                                                    break;
	                                                case 1:
	                                                    pVal->first.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	                                                    break;
	                                                case 2:
	                                                    pVal->first.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	                                                    break;
	                                            default:
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (ret) {
	        /*Decode second */
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->second.time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME_MICROSECONDS;
	        if (ret) {
	            /*Decode received_time */
	            /*Decode microseconds */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->second.received_time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME_MICROSECONDS;
	            if (ret) {
	                /*Decode image */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE;
	                pVal->second.image.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->second.image.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_ReadByte(pBitStrm, &(pVal->second.image.arr[i1])); 
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE;
	                }
	                if (ret) {
	                    /*Decode attributes */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES;
	                    pVal->second.attributes.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->second.attributes.nCount) && ret; i1++) 
	                    {
	                    	/*Decode data */
	                    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA;
	                    	pVal->second.attributes.arr[i1].data.nCount = (long)nCount;
	                    		
	                    	for(i2=0; (i2 < (int)pVal->second.attributes.arr[i1].data.nCount) && ret; i2++) 
	                    	{
	                    		ret = BitStream_ReadByte(pBitStrm, &(pVal->second.attributes.arr[i1].data.arr[i2])); 
	                    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA;
	                    	}
	                    	if (ret) {
	                    	    /*Decode name_val */
	                    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	                    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL;
	                    	    pVal->second.attributes.arr[i1].name_val.nCount = (long)nCount;
	                    	    	
	                    	    for(i2=0; (i2 < (int)pVal->second.attributes.arr[i1].name_val.nCount) && ret; i2++) 
	                    	    {
	                    	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->second.attributes.arr[i1].name_val.arr[i2])); 
	                    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL;
	                    	    }
	                    	}
	                    }
	                    if (ret) {
	                        /*Decode size_val */
	                        /*Decode width */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->second.size_val.width)), 0, 65535);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH;
	                        if (ret) {
	                            /*Decode height */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->second.size_val.height)), 0, 65535);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT;
	                        }
	                        if (ret) {
	                            /*Decode data_depth */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->second.data_depth)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH;
	                            if (ret) {
	                                /*Decode pixel_size */
	                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->second.pixel_size)), 0, 4294967295LL);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE;
	                                if (ret) {
	                                    /*Decode row_size */
	                                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->second.row_size)), 0, 4294967295LL);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE;
	                                    if (ret) {
	                                        /*Decode frame_mode */
	                                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 15);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;
	                                        if (ret) {
	                                            switch (intVal) {
	                                                case 0:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	                                                    break;
	                                                case 1:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	                                                    break;
	                                                case 2:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	                                                    break;
	                                                case 3:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	                                                    break;
	                                                case 4:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	                                                    break;
	                                                case 5:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	                                                    break;
	                                                case 6:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	                                                    break;
	                                                case 7:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	                                                    break;
	                                                case 8:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	                                                    break;
	                                                case 9:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	                                                    break;
	                                                case 10:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	                                                    break;
	                                                case 11:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	                                                    break;
	                                                case 12:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	                                                    break;
	                                                case 13:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	                                                    break;
	                                                case 14:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	                                                    break;
	                                                case 15:
	                                                    pVal->second.frame_mode = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	                                                    break;
	                                            default:
	                                                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;                 /*COVERAGE_IGNORE*/
	                                            }
	                                        }
	                                        if (ret) {
	                                            /*Decode frame_status */
	                                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(intVal)), 0, 2);
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;
	                                            if (ret) {
	                                                switch (intVal) {
	                                                    case 0:
	                                                        pVal->second.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	                                                        break;
	                                                    case 1:
	                                                        pVal->second.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	                                                        break;
	                                                    case 2:
	                                                        pVal->second.frame_status = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	                                                        break;
	                                                default:
	                                                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	                                                    *pErrCode = ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;                 /*COVERAGE_IGNORE*/
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (ret) {
	            /*Decode id */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->id)), 0, 4294967295LL);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_ID;
	        }
	    }
	}

    return ret && asn1SccBase_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointTransform_m_Initialize(asn1SccBase_JointTransform_m* pVal)
{


	/*set sourceframe */
	asn1SccT_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	asn1SccT_String_Initialize((&(pVal->targetframe)));
	/*set rotationaxis */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
}

flag asn1SccBase_JointTransform_m_IsConstraintValid(const asn1SccBase_JointTransform_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((0 <= pVal->sourceframe.nCount) && (pVal->sourceframe.nCount <= 40));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME;
    if (ret) {
        ret = ((0 <= pVal->targetframe.nCount) && (pVal->targetframe.nCount <= 40));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME;
        if (ret) {
            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA;
            for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM;
            }

        }
    }

	return ret;
}

flag asn1SccBase_JointTransform_m_Encode(const asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = asn1SccT_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = asn1SccT_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = asn1SccWrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransform_m_Decode(asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = asn1SccT_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = asn1SccT_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = asn1SccWrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointTransform_m_ACN_Encode(const asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->sourceframe.nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->sourceframe.arr[i1]);
	    }
	    if (ret) {
	        /*Encode targetframe */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->targetframe.nCount, 0, 40);
	        	
	        for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->targetframe.arr[i1]);
	        }
	        if (ret) {
	            /*Encode rotationaxis */
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->rotationaxis.data.nCount, 1, 3);
	            	
	            for(i1=0; (i1 < (int)pVal->rotationaxis.data.nCount) && ret; i1++) 
	            {
	            	BitStream_EncodeReal(pBitStrm, pVal->rotationaxis.data.arr[i1]);
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransform_m_ACN_Decode(asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode sourceframe */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME;
	pVal->sourceframe.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->sourceframe.arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME;
	}
	if (ret) {
	    /*Decode targetframe */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_TARGETFRAME;
	    pVal->targetframe.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->targetframe.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_TARGETFRAME;
	    }
	    if (ret) {
	        /*Decode rotationaxis */
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA;
	        pVal->rotationaxis.data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->rotationaxis.data.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->rotationaxis.data.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM;
	        }
	    }
	}

    return ret && asn1SccBase_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccBase_JointTransform_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
    for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
    {
    	ret = ((0 <= pVal->arr[i1].sourceframe.nCount) && (pVal->arr[i1].sourceframe.nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME;
    	if (ret) {
    	    ret = ((0 <= pVal->arr[i1].targetframe.nCount) && (pVal->arr[i1].targetframe.nCount <= 40));
    	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME;
    	    if (ret) {
    	        ret = ((1 <= pVal->arr[i1].rotationaxis.data.nCount) && (pVal->arr[i1].rotationaxis.data.nCount <= 3));
    	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA;
    	        for(i2 = 0; ret && i2 < pVal->arr[i1].rotationaxis.data.nCount; i2++) 
    	        {
    	        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].rotationaxis.data.arr[i2]) && (pVal->arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
    	        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM;
    	        }

    	    }
    	}
    }


	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTransform_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_ACN_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	/*Encode sourceframe */
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].sourceframe.nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].sourceframe.nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->arr[i1].sourceframe.arr[i2]);
	    	}
	    	if (ret) {
	    	    /*Encode targetframe */
	    	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].targetframe.nCount, 0, 40);
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->arr[i1].targetframe.nCount) && ret; i2++) 
	    	    {
	    	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1].targetframe.arr[i2]);
	    	    }
	    	    if (ret) {
	    	        /*Encode rotationaxis */
	    	        /*Encode data */
	    	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].rotationaxis.data.nCount, 1, 3);
	    	        	
	    	        for(i2=0; (i2 < (int)pVal->arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	    	        {
	    	        	BitStream_EncodeReal(pBitStrm, pVal->arr[i1].rotationaxis.data.arr[i2]);
	    	        }
	    	    }
	    	}
	    }
    }

	
    return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_ACN_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		/*Decode sourceframe */
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME;
		pVal->arr[i1].sourceframe.nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].sourceframe.nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1].sourceframe.arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME;
		}
		if (ret) {
		    /*Decode targetframe */
		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		    *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME;
		    pVal->arr[i1].targetframe.nCount = (long)nCount;
		    	
		    for(i2=0; (i2 < (int)pVal->arr[i1].targetframe.nCount) && ret; i2++) 
		    {
		    	ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1].targetframe.arr[i2])); 
		    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME;
		    }
		    if (ret) {
		        /*Decode rotationaxis */
		        /*Decode data */
		        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
		        *pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA;
		        pVal->arr[i1].rotationaxis.data.nCount = (long)nCount;
		        	
		        for(i2=0; (i2 < (int)pVal->arr[i1].rotationaxis.data.nCount) && ret; i2++) 
		        {
		        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->arr[i1].rotationaxis.data.arr[i2])));
		        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM;
		        }
		    }
		}
	}

    return ret && asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_JointTransformVector_m_names_Initialize(asn1SccBase_JointTransformVector_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_JointTransformVector_m_Initialize(asn1SccBase_JointTransformVector_m* pVal)
{


	/*set names */
	asn1SccBase_JointTransformVector_m_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
}

flag asn1SccBase_JointTransformVector_m_IsConstraintValid(const asn1SccBase_JointTransformVector_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((0 <= pVal->elements.arr[i1].sourceframe.nCount) && (pVal->elements.arr[i1].sourceframe.nCount <= 40));
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME;
        	if (ret) {
        	    ret = ((0 <= pVal->elements.arr[i1].targetframe.nCount) && (pVal->elements.arr[i1].targetframe.nCount <= 40));
        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME;
        	    if (ret) {
        	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
        	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
        	        {
        	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
        	        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
        	        }

        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_JointTransformVector_m_Encode(const asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransformVector_m_Decode(asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_JointTransformVector_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_JointTransformVector_m_ACN_Encode(const asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode sourceframe */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].sourceframe.nCount, 0, 40);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	        	{
	        		BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].sourceframe.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode targetframe */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].targetframe.nCount, 0, 40);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].targetframe.arr[i2]);
	        	    }
	        	    if (ret) {
	        	        /*Encode rotationaxis */
	        	        /*Encode data */
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.nCount, 1, 3);
	        	        	
	        	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	        	        {
	        	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.arr[i2]);
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_JointTransformVector_m_ACN_Decode(asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode sourceframe */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME;
	    	pVal->elements.arr[i1].sourceframe.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].sourceframe.arr[i2])); 
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME;
	    	}
	    	if (ret) {
	    	    /*Decode targetframe */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME;
	    	    pVal->elements.arr[i1].targetframe.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].targetframe.arr[i2])); 
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME;
	    	    }
	    	    if (ret) {
	    	        /*Decode rotationaxis */
	    	        /*Decode data */
	    	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
	    	        pVal->elements.arr[i1].rotationaxis.data.nCount = (long)nCount;
	    	        	
	    	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	    	        {
	    	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].rotationaxis.data.arr[i2])));
	    	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_JointTransformVector_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_base_JointTransform_m_names_Initialize(asn1SccBase_NamedVector_base_JointTransform_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_base_JointTransform_m_Initialize(asn1SccBase_NamedVector_base_JointTransform_m* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_base_JointTransform_m_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((0 <= pVal->elements.arr[i1].sourceframe.nCount) && (pVal->elements.arr[i1].sourceframe.nCount <= 40));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME;
        	if (ret) {
        	    ret = ((0 <= pVal->elements.arr[i1].targetframe.nCount) && (pVal->elements.arr[i1].targetframe.nCount <= 40));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME;
        	    if (ret) {
        	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
        	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
        	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
        	        {
        	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
        	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
        	        }

        	    }
        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_Encode(const asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_Decode(asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_base_JointTransform_m_ACN_Encode(const asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode sourceframe */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].sourceframe.nCount, 0, 40);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	        	{
	        		BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].sourceframe.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode targetframe */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].targetframe.nCount, 0, 40);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_AppendByte0(pBitStrm, pVal->elements.arr[i1].targetframe.arr[i2]);
	        	    }
	        	    if (ret) {
	        	        /*Encode rotationaxis */
	        	        /*Encode data */
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.nCount, 1, 3);
	        	        	
	        	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	        	        {
	        	        	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].rotationaxis.data.arr[i2]);
	        	        }
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_ACN_Decode(asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode sourceframe */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME;
	    	pVal->elements.arr[i1].sourceframe.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].sourceframe.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].sourceframe.arr[i2])); 
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME;
	    	}
	    	if (ret) {
	    	    /*Decode targetframe */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME;
	    	    pVal->elements.arr[i1].targetframe.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].targetframe.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->elements.arr[i1].targetframe.arr[i2])); 
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME;
	    	    }
	    	    if (ret) {
	    	        /*Decode rotationaxis */
	    	        /*Decode data */
	    	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
	    	        pVal->elements.arr[i1].rotationaxis.data.nCount = (long)nCount;
	    	        	
	    	        for(i2=0; (i2 < (int)pVal->elements.arr[i1].rotationaxis.data.nCount) && ret; i2++) 
	    	        {
	    	        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].rotationaxis.data.arr[i2])));
	    	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
	    	        }
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_RigidBodyState_m_Initialize(asn1SccBase_samples_RigidBodyState_m* pVal)
{


	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
	/*set sourceframe */
	asn1SccT_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	asn1SccT_String_Initialize((&(pVal->targetframe)));
	/*set position */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->position)));
	/*set cov_position */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_position)));
	/*set orientation */
	asn1SccWrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov_orientation */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
	/*set velocity */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->velocity)));
	/*set cov_velocity */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
	/*set angular_velocity */
	asn1SccWrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
	/*set cov_angular_velocity */
	asn1SccWrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
}

flag asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyState_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = TRUE;
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_MICROSECONDS;
    if (ret) {
        ret = ((0 <= pVal->sourceframe.nCount) && (pVal->sourceframe.nCount <= 40));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME;
        if (ret) {
            ret = ((0 <= pVal->targetframe.nCount) && (pVal->targetframe.nCount <= 40));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME;
            if (ret) {
                ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA;
                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM;
                }

                if (ret) {
                    ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA;
                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM;
                    }

                    if (ret) {
                        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM;
                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM;
                        }

                        if (ret) {
                            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE;
                        }
                        if (ret) {
                            ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA;
                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM;
                            }

                            if (ret) {
                                ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA;
                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM;
                                }

                                if (ret) {
                                    ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA;
                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++) 
                                    {
                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM;
                                    }

                                    if (ret) {
                                        ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA;
                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++) 
                                        {
                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM;
                                        }

                                        if (ret) {
                                            ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
                                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA;
                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++) 
                                            {
                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM;
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_m_Encode(const asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = asn1SccT_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = asn1SccT_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = asn1SccWrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = asn1SccWrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = asn1SccWrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = asn1SccWrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyState_m_Decode(asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = asn1SccT_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = asn1SccT_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = asn1SccWrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = asn1SccWrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = asn1SccWrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = asn1SccWrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_RigidBodyState_m_ACN_Encode(const asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    /*Encode microseconds */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	    if (ret) {
	        /*Encode sourceframe */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->sourceframe.nCount, 0, 40);
	        	
	        for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->sourceframe.arr[i1]);
	        }
	        if (ret) {
	            /*Encode targetframe */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->targetframe.nCount, 0, 40);
	            	
	            for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	            {
	            	BitStream_AppendByte0(pBitStrm, pVal->targetframe.arr[i1]);
	            }
	            if (ret) {
	                /*Encode position */
	                /*Encode data */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->position.data.nCount, 1, 3);
	                	
	                for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	                {
	                	BitStream_EncodeReal(pBitStrm, pVal->position.data.arr[i1]);
	                }
	                if (ret) {
	                    /*Encode cov_position */
	                    /*Encode data */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_position.data.nCount, 1, 9);
	                    	
	                    for(i1=0; (i1 < (int)pVal->cov_position.data.nCount) && ret; i1++) 
	                    {
	                    	BitStream_EncodeReal(pBitStrm, pVal->cov_position.data.arr[i1]);
	                    }
	                    if (ret) {
	                        /*Encode orientation */
	                        /*Encode im */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->orientation.im.nCount, 1, 3);
	                        	
	                        for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	                        {
	                        	BitStream_EncodeReal(pBitStrm, pVal->orientation.im.arr[i1]);
	                        }
	                        if (ret) {
	                            /*Encode re */
	                            BitStream_EncodeReal(pBitStrm, pVal->orientation.re);
	                        }
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            /*Encode data */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_orientation.data.nCount, 1, 9);
	                            	
	                            for(i1=0; (i1 < (int)pVal->cov_orientation.data.nCount) && ret; i1++) 
	                            {
	                            	BitStream_EncodeReal(pBitStrm, pVal->cov_orientation.data.arr[i1]);
	                            }
	                            if (ret) {
	                                /*Encode velocity */
	                                /*Encode data */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->velocity.data.nCount, 1, 3);
	                                	
	                                for(i1=0; (i1 < (int)pVal->velocity.data.nCount) && ret; i1++) 
	                                {
	                                	BitStream_EncodeReal(pBitStrm, pVal->velocity.data.arr[i1]);
	                                }
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    /*Encode data */
	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_velocity.data.nCount, 1, 9);
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->cov_velocity.data.nCount) && ret; i1++) 
	                                    {
	                                    	BitStream_EncodeReal(pBitStrm, pVal->cov_velocity.data.arr[i1]);
	                                    }
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        /*Encode data */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->angular_velocity.data.nCount, 1, 3);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->angular_velocity.data.nCount) && ret; i1++) 
	                                        {
	                                        	BitStream_EncodeReal(pBitStrm, pVal->angular_velocity.data.arr[i1]);
	                                        }
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            /*Encode data */
	                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->cov_angular_velocity.data.nCount, 1, 9);
	                                            	
	                                            for(i1=0; (i1 < (int)pVal->cov_angular_velocity.data.nCount) && ret; i1++) 
	                                            {
	                                            	BitStream_EncodeReal(pBitStrm, pVal->cov_angular_velocity.data.arr[i1]);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_RigidBodyState_m_ACN_Decode(asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	/*Decode microseconds */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_MICROSECONDS;
	if (ret) {
	    /*Decode sourceframe */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME;
	    pVal->sourceframe.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->sourceframe.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->sourceframe.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME;
	    }
	    if (ret) {
	        /*Decode targetframe */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME;
	        pVal->targetframe.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->targetframe.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->targetframe.arr[i1])); 
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME;
	        }
	        if (ret) {
	            /*Decode position */
	            /*Decode data */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA;
	            pVal->position.data.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->position.data.nCount) && ret; i1++) 
	            {
	            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->position.data.arr[i1])));
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM;
	            }
	            if (ret) {
	                /*Decode cov_position */
	                /*Decode data */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA;
	                pVal->cov_position.data.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->cov_position.data.nCount) && ret; i1++) 
	                {
	                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_position.data.arr[i1])));
	                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM;
	                }
	                if (ret) {
	                    /*Decode orientation */
	                    /*Decode im */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM;
	                    pVal->orientation.im.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->orientation.im.nCount) && ret; i1++) 
	                    {
	                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.im.arr[i1])));
	                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM;
	                    }
	                    if (ret) {
	                        /*Decode re */
	                        ret = BitStream_DecodeReal(pBitStrm, (&(pVal->orientation.re)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE;
	                    }
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        /*Decode data */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA;
	                        pVal->cov_orientation.data.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->cov_orientation.data.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_orientation.data.arr[i1])));
	                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM;
	                        }
	                        if (ret) {
	                            /*Decode velocity */
	                            /*Decode data */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA;
	                            pVal->velocity.data.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->velocity.data.nCount) && ret; i1++) 
	                            {
	                            	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->velocity.data.arr[i1])));
	                            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM;
	                            }
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                /*Decode data */
	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA;
	                                pVal->cov_velocity.data.nCount = (long)nCount;
	                                	
	                                for(i1=0; (i1 < (int)pVal->cov_velocity.data.nCount) && ret; i1++) 
	                                {
	                                	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_velocity.data.arr[i1])));
	                                	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM;
	                                }
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    /*Decode data */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA;
	                                    pVal->angular_velocity.data.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->angular_velocity.data.nCount) && ret; i1++) 
	                                    {
	                                    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->angular_velocity.data.arr[i1])));
	                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM;
	                                    }
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        /*Decode data */
	                                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA;
	                                        pVal->cov_angular_velocity.data.nCount = (long)nCount;
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->cov_angular_velocity.data.nCount) && ret; i1++) 
	                                        {
	                                        	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->cov_angular_velocity.data.arr[i1])));
	                                        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

    return ret && asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_NamedVector_base_Wrench_m_names_Initialize(asn1SccBase_NamedVector_base_Wrench_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_NamedVector_base_Wrench_m_Initialize(asn1SccBase_NamedVector_base_Wrench_m* pVal)
{


	/*set names */
	asn1SccBase_NamedVector_base_Wrench_m_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
}

flag asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM;
        	}

        	if (ret) {
        	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
        	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA;
        	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
        	    }

        	}
        }

    }

	return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_Encode(const asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_Decode(asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_NamedVector_base_Wrench_m_ACN_Encode(const asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode force */
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].force.data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].force.data.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode torque */
	        	    /*Encode data */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].torque.data.nCount, 1, 3);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].torque.data.arr[i2]);
	        	    }
	        	}
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_ACN_Decode(asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode force */
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA;
	    	pVal->elements.arr[i1].force.data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].force.data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM;
	    	}
	    	if (ret) {
	    	    /*Decode torque */
	    	    /*Decode data */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA;
	    	    pVal->elements.arr[i1].torque.data.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].torque.data.arr[i2])));
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
	    	    }
	    	}
	    }
	}

    return ret && asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void asn1SccBase_samples_Wrenches_m_names_Initialize(asn1SccBase_samples_Wrenches_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    asn1SccT_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void asn1SccBase_samples_Wrenches_m_Initialize(asn1SccBase_samples_Wrenches_m* pVal)
{


	/*set names */
	asn1SccBase_samples_Wrenches_m_names_Initialize((&(pVal->names)));
	/*set elements */
	asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
	/*set time */
	asn1SccBase_Time_Initialize((&(pVal->time)));
}

flag asn1SccBase_samples_Wrenches_m_IsConstraintValid(const asn1SccBase_samples_Wrenches_m *pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES;
    for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
    {
    	ret = ((0 <= pVal->names.arr[i1].nCount) && (pVal->names.arr[i1].nCount <= 40));
    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM;
    }

    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS;
        for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
        {
        	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA;
        	for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
        	{
        		ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
        		*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM;
        	}

        	if (ret) {
        	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
        	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA;
        	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
        	    }

        	}
        }

        if (ret) {
            ret = TRUE;
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_TIME_MICROSECONDS;
        }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_m_Encode(const asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrenches_m_Decode(asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccBase_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBase_samples_Wrenches_m_ACN_Encode(const asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.arr[i1].nCount, 0, 40);
	    		
	    	for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
	    	{
	    		BitStream_AppendByte0(pBitStrm, pVal->names.arr[i1].arr[i2]);
	    	}
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	/*Encode force */
	        	/*Encode data */
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].force.data.nCount, 1, 3);
	        		
	        	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	        	{
	        		BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].force.data.arr[i2]);
	        	}
	        	if (ret) {
	        	    /*Encode torque */
	        	    /*Encode data */
	        	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.arr[i1].torque.data.nCount, 1, 3);
	        	    	
	        	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	        	    {
	        	    	BitStream_EncodeReal(pBitStrm, pVal->elements.arr[i1].torque.data.arr[i2]);
	        	    }
	        	}
	        }
	        if (ret) {
	            /*Encode time */
	            /*Encode microseconds */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time.microseconds, LLONG_MIN, 9223372036854775807LL);
	        }
	    }
    }

	
    return ret;
}

flag asn1SccBase_samples_Wrenches_m_ACN_Decode(asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	int i2;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM;
		pVal->names.arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->names.arr[i1].nCount) && ret; i2++) 
		{
			ret = BitStream_ReadByte(pBitStrm, &(pVal->names.arr[i1].arr[i2])); 
			*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM;
		}
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	/*Decode force */
	    	/*Decode data */
	    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA;
	    	pVal->elements.arr[i1].force.data.nCount = (long)nCount;
	    		
	    	for(i2=0; (i2 < (int)pVal->elements.arr[i1].force.data.nCount) && ret; i2++) 
	    	{
	    		ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].force.data.arr[i2])));
	    		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM;
	    	}
	    	if (ret) {
	    	    /*Decode torque */
	    	    /*Decode data */
	    	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA;
	    	    pVal->elements.arr[i1].torque.data.nCount = (long)nCount;
	    	    	
	    	    for(i2=0; (i2 < (int)pVal->elements.arr[i1].torque.data.nCount) && ret; i2++) 
	    	    {
	    	    	ret = BitStream_DecodeReal(pBitStrm, (&(pVal->elements.arr[i1].torque.data.arr[i2])));
	    	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
	    	    }
	    	}
	    }
	    if (ret) {
	        /*Decode time */
	        /*Decode microseconds */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, (&(pVal->time.microseconds)), LLONG_MIN, 9223372036854775807LL);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_BASE_SAMPLES_WRENCHES_M_TIME_MICROSECONDS;
	    }
	}

    return ret && asn1SccBase_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode);
}

